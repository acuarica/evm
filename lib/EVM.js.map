{"version":3,"file":"EVM.js","mappings":"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","sources":["webpack://evm/webpack/universalModuleDefinition","webpack://evm/./src/evm/env.ts","webpack://evm/./src/evm/expr.ts","webpack://evm/./src/evm/flow.ts","webpack://evm/./src/evm/index.ts","webpack://evm/./src/evm/log.ts","webpack://evm/./src/evm/logic.ts","webpack://evm/./src/evm/math.ts","webpack://evm/./src/evm/memory.ts","webpack://evm/./src/evm/stack.ts","webpack://evm/./src/evm/storage.ts","webpack://evm/./src/evm/sym.ts","webpack://evm/./src/evm/system.ts","webpack://evm/./src/metadata.ts","webpack://evm/./src/opcode.ts","webpack://evm/./src/state.ts","webpack://evm/webpack/bootstrap","webpack://evm/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","import type { Stack } from '../state';\nimport { type Expr, Tag } from './expr';\n\nexport class CallValue extends Tag('CallValue') {\n    eval(): Expr {\n        return this;\n    }\n    str(): string {\n        return 'msg.value';\n    }\n}\n\nexport class CallDataLoad extends Tag('CallDataLoad') {\n    constructor(public location: Expr) {\n        super();\n    }\n    eval(): Expr {\n        this.location = this.location.eval();\n        return this;\n    }\n    str(): string {\n        return this.location.isVal() && this.location.val === 0n\n            ? 'msg.data'\n            : this.location.isVal() && (this.location.val - 4n) % 32n === 0n\n            ? `_arg${(this.location.val - 4n) / 32n}`\n            : `msg.data[${this.location._str(CallDataLoad.prec)}]`;\n    }\n}\n\nexport class CallDataSize extends Tag('CallDataSize') {\n    eval(): Expr {\n        return this;\n    }\n    str(): string {\n        return 'msg.data.length';\n    }\n}\n\nexport const ENV = {\n    /**\n     * Get deposited value by the instruction/transaction responsible for this execution.\n     *\n     * @param stack\n     */\n    CALLVALUE: (stack: Stack<Expr>): void => stack.push(new CallValue()),\n    CALLDATALOAD: (stack: Stack<Expr>): void => {\n        const location = stack.pop();\n        stack.push(new CallDataLoad(location));\n    },\n    CALLDATASIZE: (stack: Stack<Expr>): void => stack.push(new CallDataSize()),\n};\n","import type { Add, Div, Exp, Mod, Mul, Sub } from './math';\nimport type { And, Byte, Eq, Gt, IsZero, Lt, Not, Or, Sar, Shl, Shr, Sig, Xor } from './logic';\nimport type { CallDataLoad, CallDataSize, CallValue } from './env';\nimport type { DataCopy, Symbol0, Symbol1 } from './sym';\nimport type { MLoad, MStore } from './memory';\nimport type {\n    Call,\n    CallCode,\n    Create,\n    Create2,\n    DelegateCall,\n    Invalid,\n    Return,\n    ReturnData,\n    Revert,\n    SelfDestruct,\n    Sha3,\n    StaticCall,\n    Stop,\n} from './system';\nimport type { Log } from './log';\nimport type { Branch, Jump, JumpDest, Jumpi, SigCase } from './flow';\nimport type { MappingLoad, MappingStore, SLoad, SStore } from './storage';\n\n/**\n *\n */\nexport type Expr =\n    | Val\n    | Add\n    | Mul\n    | Sub\n    | Div\n    | Mod\n    | Exp\n    | Lt\n    | Gt\n    | Eq\n    | IsZero\n    | And\n    | Or\n    | Xor\n    | Not\n    | Byte\n    | Shl\n    | Shr\n    | Sar\n    | Sig\n    | CallValue\n    | CallDataLoad\n    | CallDataSize\n    | Symbol0\n    | Symbol1\n    | DataCopy\n    | MLoad\n    | Sha3\n    | Create\n    | Call\n    | ReturnData\n    | CallCode\n    | Create2\n    | StaticCall\n    | DelegateCall\n    | SLoad\n    | MappingLoad;\n\n/**\n * Base definition for any type that is `Stmt`.\n */\nexport interface IInst {\n    /**\n     * The `name` tag of this `IStmt`.\n     */\n    readonly name: string;\n\n    eval(): Inst;\n\n    next?(): Branch[];\n}\n\n/**\n *\n */\nexport type Inst =\n    | MStore\n    | Stop\n    | Return\n    | Revert\n    | SelfDestruct\n    | Invalid\n    | Log\n    | Jump\n    | Jumpi\n    | JumpDest\n    | SigCase\n    | SStore\n    | MappingStore;\n\nexport function Tag<N extends string>(tag: N, prec: number = Val.prec) {\n    abstract class Tag {\n        readonly tag: N = tag;\n\n        static readonly prec = prec;\n\n        readonly type?: string;\n\n        isVal(): this is Val {\n            return this.tag === 'Val';\n        }\n\n        isZero(): this is Val {\n            return this.isVal() && this.val === 0n;\n        }\n\n        isJumpDest() {\n            return this.isVal() && this.jumpDest !== null;\n        }\n\n        /**\n         * hghghg\n         */\n        abstract eval(): Expr;\n\n        /**\n         *\n         */\n        abstract str(): string;\n\n        _str(prec: any): string {\n            const text = this.str();\n            return Tag.prec < prec ? `(${text})` : text;\n        }\n\n        toString() {\n            return this.str();\n        }\n    }\n\n    return Tag;\n}\n\nexport function Bin<N extends string>(tag: N, op: string, prec: number) {\n    abstract class Bin extends Tag(tag, prec) {\n        constructor(readonly left: Expr, readonly right: Expr) {\n            super();\n        }\n\n        str() {\n            return `${this.left._str(prec)} ${op} ${this.right._str(prec)}`;\n        }\n    }\n\n    return Bin;\n}\n\nexport class Val extends Tag('Val', 16) {\n    jumpDest: number | null = null;\n\n    constructor(readonly val: bigint, readonly isPush = false) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return `${this.isJumpDest() ? '[J]' : ''}0x${this.val.toString(16)}`;\n    }\n}\n","import type { Inst, Expr, IInst, Val } from './expr';\nimport type { State } from '../state';\nimport type { Sig } from './logic';\nimport { type decode, formatOpcode, type Opcode } from '../opcode';\n\nexport class Branch {\n    constructor(readonly pc: number, readonly state: State<Inst, Expr>) {}\n\n    get key() {\n        return this.pc;\n    }\n}\n\nexport class Jump implements IInst {\n    readonly name = 'Jump';\n\n    constructor(readonly offset: Expr, readonly destBranch: Branch) {}\n\n    eval() {\n        return this;\n    }\n    toString() {\n        return `goto :${this.offset} branch:${this.destBranch.key}`;\n    }\n    next() {\n        return [this.destBranch];\n    }\n}\n\nexport class Jumpi implements IInst {\n    readonly name = 'Jumpi';\n\n    readonly evalCond: Expr;\n\n    constructor(\n        readonly cond: Expr,\n        readonly offset: Expr,\n        readonly fallBranch: Branch,\n        readonly destBranch: Branch\n    ) {\n        this.evalCond = cond.eval();\n    }\n\n    eval() {\n        return this;\n    }\n    toString() {\n        return `when ${this.cond} goto ${this.destBranch.key} or fall ${this.fallBranch.key}`;\n    }\n\n    next() {\n        return this.evalCond.isVal()\n            ? this.evalCond.val === 0n\n                ? [this.fallBranch]\n                : [this.destBranch]\n            : [this.destBranch, this.fallBranch];\n    }\n}\n\nexport class JumpDest implements IInst {\n    readonly name = 'JumpDest';\n    constructor(readonly fallBranch: Branch) {}\n    eval() {\n        return this;\n    }\n    toString() {\n        return `fall: ${this.fallBranch.key}:`;\n    }\n\n    next() {\n        return [this.fallBranch];\n    }\n}\n\nexport class SigCase implements IInst {\n    readonly name = 'SigCase';\n    constructor(readonly condition: Sig, readonly offset: Expr, readonly fallBranch: Branch) {}\n    eval() {\n        return this;\n    }\n    toString() {\n        return `case when ${this.condition} goto ${this.offset} or fall ${this.fallBranch.key}`;\n    }\n\n    next(): Branch[] {\n        return [this.fallBranch];\n    }\n}\n\nexport function makeBranch(pc: number, state: State<Inst, Expr>) {\n    return new Branch(pc, state.clone());\n}\n\nexport interface ISelectorBranches {\n    /**\n     * store selectors starting point.\n     */\n    readonly functionBranches: Map<string, { pc: number; state: State<Inst, Expr> }>;\n}\n\nexport function FLOW(\n    { opcodes, jumpdests }: ReturnType<typeof decode>,\n    { functionBranches }: ISelectorBranches\n) {\n    return {\n        JUMP: (_opcode: Opcode, state: State<Inst, Expr>): void => {\n            const offset = state.stack.pop();\n            const destpc = getDest(offset);\n            const destBranch = makeBranch(destpc, state);\n            state.halt(new Jump(offset, destBranch));\n        },\n\n        JUMPI: (opcode: Opcode, state: State<Inst, Expr>): void => {\n            const offset = state.stack.pop();\n            const cond = state.stack.pop();\n            const destpc = getDest(offset);\n\n            const fallBranch = makeBranch(opcode.pc + 1, state);\n\n            let last: SigCase | Jumpi;\n            if (cond.tag === 'Sig') {\n                functionBranches.set(cond.selector, {\n                    pc: destpc,\n                    state: state.clone(),\n                });\n                last = new SigCase(cond, offset, fallBranch);\n            } else {\n                last = new Jumpi(cond, offset, fallBranch, makeBranch(destpc, state));\n            }\n            state.halt(last);\n        },\n    };\n\n    /**\n     *\n     * @param offset\n     * @returns\n     */\n    function getDest(offset: Expr): number {\n        const offset2 = offset.eval();\n        if (!offset2.isVal()) {\n            throw new Error(`Expected numeric offset, found ${offset}`);\n        }\n        const destpc = jumpdests[Number(offset2.val)];\n        if (destpc !== undefined) {\n            (offset as Val).jumpDest = destpc;\n            return destpc;\n        } else {\n            const dest = opcodes.find(o => o.offset === Number(offset2.val));\n            if (!dest) {\n                throw new Error('Expected `JUMPDEST` in JUMP destination, but none was found');\n            }\n            throw new Error('JUMP destination should be JUMPDEST but found' + formatOpcode(dest));\n        }\n    }\n}\n","import { decode, OPCODES, type Opcode, MNEMONICS } from '../opcode';\nimport { type Stack, State as TState } from '../state';\nimport { type Metadata, stripMetadataHash } from '../metadata';\n\nimport type { Expr, IInst, Inst } from './expr';\n\nimport { PUSHES, STACK } from './stack';\nimport { MATH } from './math';\nimport { LOGIC } from './logic';\nimport { ENV } from './env';\nimport { SYM as SYMBOLS } from './sym';\nimport { MEMORY } from './memory';\nimport { Invalid, INVALID, PC, SYSTEM } from './system';\nimport { LOGS, type IEvents } from './log';\nimport { type IStore, STORAGE } from './storage';\nimport { Branch, FLOW, type ISelectorBranches, JumpDest, makeBranch } from './flow';\n\ntype State = TState<Inst, Expr>;\n\nfunction make<F, T extends { [mnemonic: string]: F }>(\n    table: T,\n    adapter: (fn: F) => (opcode: Opcode, state: State) => void\n) {\n    return Object.fromEntries(\n        Object.entries(table).map(([mnemonic, fn]) => [mnemonic, adapter(fn)])\n    ) as { [mnemonic in keyof T]: (opcode: Opcode, state: State) => void };\n}\n\nfunction makeStack<T extends { [mnemonic: string]: (stack: Stack<Expr>) => void }>(table: T) {\n    return make(table, (fn: (stack: Stack<Expr>) => void) => (_opcode, state) => fn(state.stack));\n}\n\nfunction makeState<T extends { [mnemonic: string]: (state: State) => void }>(table: T) {\n    return make(table, (fn: (state: State) => void) => (_opcode, state) => fn(state));\n}\n\nconst TABLE = {\n    ...makeStack(MATH),\n    ...makeStack(LOGIC),\n    ...makeStack(ENV),\n    ...makeState(SYMBOLS),\n    ...makeState(MEMORY),\n    JUMPDEST: (_opcode: Opcode, _state: State) => {},\n    ...make(\n        PUSHES,\n        (fn: (pushData: Uint8Array, stack: Stack<Expr>) => void) => (opcode, state) =>\n            fn(opcode.pushData!, state.stack)\n    ),\n    ...makeStack(STACK<Expr>()),\n    ...makeState(SYSTEM),\n    PC,\n    INVALID,\n};\n\n/**\n * Swaps `insts` keying by `opcode` and fills the gaps using `INVALID` inst.\n *\n * @param insts\n * @returns\n */\nfunction fill<F>(insts: { [mnemonic in keyof typeof OPCODES]: F }) {\n    return Object.fromEntries(\n        [...Array(256).keys()].map(k => [\n            k,\n            MNEMONICS[k] === undefined ? INVALID : insts[MNEMONICS[k]],\n        ])\n    );\n}\n\nexport class EVM implements IEvents, IStore, ISelectorBranches {\n    /**\n     *\n     */\n    private readonly insts: {\n        [opcode in string]: (opcode: Opcode, state: TState<Inst, Expr>) => void;\n    };\n\n    /**\n     *\n     */\n    readonly chunks = new Map<number, { pcend: number; states: State[] }>();\n\n    /**\n     *\n     */\n    readonly errors: Invalid[] = [];\n\n    readonly events: IEvents['events'] = {};\n    readonly variables: IStore['variables'] = {};\n    readonly mappings: IStore['mappings'] = {};\n    readonly functionBranches: ISelectorBranches['functionBranches'] = new Map<\n        string,\n        { pc: number; state: State }\n    >();\n\n    /**\n     * The `Opcode[]` decoded from `bytecode`.\n     */\n    readonly opcodes: ReturnType<typeof decode>['opcodes'];\n\n    /**\n     * Jump destination (`JUMPDEST`) offsets found in `bytecode`.\n     * This is used to speed up offset search.\n     */\n    readonly jumpdests: ReturnType<typeof decode>['jumpdests'];\n\n    private constructor(\n        { opcodes, jumpdests }: ReturnType<typeof decode>,\n\n        /**\n         * The `metadataHash` part from the `bytecode`.\n         * That is, if present, the `bytecode` without its `code`.\n         */\n        readonly metadata?: Metadata\n    ) {\n        this.opcodes = opcodes;\n        this.jumpdests = jumpdests;\n\n        this.insts = fill({\n            ...TABLE,\n            ...FLOW({ opcodes, jumpdests }, this),\n            ...makeState(STORAGE(this)),\n            ...makeState(LOGS(this)),\n        });\n    }\n\n    /**\n     *\n     * @param bytecode\n     * @returns\n     */\n    static from(bytecode: string): EVM {\n        /**\n         * The `code` part from the `bytecode`.\n         * That is, the `bytecode` without its metadata hash, if any.\n         */\n        const [code, metadata] = stripMetadataHash(bytecode);\n        return new EVM(decode(Buffer.from(code.replace('0x', ''), 'hex')), metadata);\n    }\n\n    /**\n     *\n     */\n    start() {\n        this.run(0, new TState());\n        for (const [, branch] of this.functionBranches) {\n            this.run(branch.pc, branch.state);\n        }\n    }\n\n    run(pc0: number, state: State) {\n        const branches: Branch[] = [new Branch(pc0, state)];\n        while (branches.length > 0) {\n            // The non-null assertion operator `!` is required because the guard does not track array's emptiness.\n            // See https://github.com/microsoft/TypeScript/issues/30406.\n            const branch = branches.shift()!;\n\n            const chunk = this.chunks.get(branch.pc);\n            if (chunk !== undefined && chunk.states.length > 10) {\n                continue;\n            }\n\n            this.exec(branch.pc, branch.state);\n            const last = branch.state.last! as IInst;\n            if (last.next) {\n                for (const b of last.next()) {\n                    // const s = gc(b, this.chunks);\n                    // if (s === undefined) {\n                    branches.unshift(b);\n                    // } else {\n                    //     b.state = s;\n                    // }\n                }\n                // branches.unshift(...last.next());\n            }\n        }\n    }\n\n    exec(pc0: number, state: State) {\n        if (state.halted) throw new Error(`State at ${pc0} must be non-halted to be \\`exec\\``);\n\n        let pc = pc0;\n        const oplen = this.opcodes.length;\n        for (; !state.halted && pc < oplen; pc++) {\n            const opcode = this.opcodes[pc];\n            try {\n                this.insts[opcode.opcode](opcode, state);\n                if (\n                    !state.halted &&\n                    pc < oplen + 1 &&\n                    this.opcodes[pc + 1].opcode === OPCODES.JUMPDEST\n                ) {\n                    const fallBranch = makeBranch(opcode.pc + 1, state);\n                    state.halt(new JumpDest(fallBranch));\n                }\n            } catch (err) {\n                const message = (err as Error).message;\n                const inv = new Invalid(\n                    `\\`${message}\\` at [${opcode.offset}] ${opcode.mnemonic} =| ${state.stack.values\n                        .slice(0, -1)\n                        .join(' | ')}`\n                );\n                state.halt(inv);\n                this.errors.push(inv);\n            }\n        }\n\n        if (!state.halted) throw new Error(`State must be halted after exec at ${pc0}:${pc}`);\n\n        let chunk = this.chunks.get(pc0);\n        if (chunk === undefined) {\n            chunk = {\n                pcend: pc,\n                states: [state],\n            };\n            this.chunks.set(pc0, chunk);\n        } else {\n            chunk.states.push(state);\n        }\n    }\n}\n\nexport function gc(b: Branch, chunks: EVM['chunks']) {\n    const chunk = chunks.get(b.pc);\n    if (chunk !== undefined) {\n        for (const s of chunk.states) {\n            if (cmp(b.state, s)) {\n                return s;\n            }\n        }\n    }\n    return undefined;\n}\n\nfunction cmp({ stack: lhs }: TState<Inst, Expr>, { stack: rhs }: TState<Inst, Expr>) {\n    if (lhs.values.length !== rhs.values.length) {\n        return false;\n    }\n    for (let i = 0; i < lhs.values.length; i++) {\n        if (!cmpval(lhs.values[i], rhs.values[i])) {\n            return false;\n        }\n    }\n    return true;\n\n    function cmpval(lhs: Expr, rhs: Expr) {\n        return !(lhs.isVal() && lhs.isPush) || !(rhs.isVal() && rhs.isPush) || lhs.val === rhs.val;\n    }\n}\n","import type { State } from '../state';\nimport { type Expr, type Inst, Val, type IInst } from './expr';\nimport { MLoad } from './memory';\n\n/**\n *\n */\nexport interface IEvents {\n    /**\n     * Events found through `LOG` instructions.\n     *\n     * The `topic` is represented as a hex string.\n     */\n    readonly events: {\n        [topic: string]: {\n            /**\n             * The signature of the event when the `topic` selector is found.\n             *\n             * For instance, if the topic is\n             * `4d6ce1e535dbade1c23defba91e23b8f791ce5edc0cc320257a2b364e4e38426`,\n             * then `sig` will be `Deposit(uint256)`.\n             */\n            sig?: string;\n            indexedCount: number;\n        };\n    };\n}\n\n/**\n *\n * @param events\n * @returns\n */\nexport function stringifyEvents(events: IEvents['events']) {\n    let text = '';\n\n    for (const [topic, event] of Object.entries(events)) {\n        text += 'event ';\n        if (event.sig === undefined) {\n            text += topic;\n        } else {\n            const eventName = event.sig.split('(')[0];\n            const params = event.sig.replace(eventName, '').substring(1).slice(0, -1);\n            if (params) {\n                text += eventName + '(';\n                text += params\n                    .split(',')\n                    .map((param, i) =>\n                        i < event.indexedCount ? `${param} indexed _arg${i}` : `${param} _arg${i}`\n                    )\n                    .join(', ');\n                text += ')';\n            } else {\n                text += event.sig;\n            }\n        }\n        text += ';\\n';\n    }\n\n    return text;\n}\n\nexport class Log implements IInst {\n    readonly name = 'Log';\n\n    constructor(\n        readonly event: IEvents['events'][string] | undefined,\n        readonly topics: Expr[],\n        readonly args: Expr[],\n        readonly mem?: { offset: Expr; size: Expr }\n    ) {}\n\n    get eventName(): string | undefined {\n        if (this.event !== undefined && this.event.sig !== undefined) {\n            return this.event.sig.split('(')[0];\n        }\n        return undefined;\n    }\n\n    eval() {\n        return new Log(\n            this.event,\n            this.topics.map(e => e.eval()),\n            this.args.map(e => e.eval()),\n            this.mem ? { offset: this.mem.offset.eval(), size: this.mem.size.eval() } : undefined\n        );\n    }\n\n    toString() {\n        return this.eventName\n            ? `emit ${this.eventName}(${[...this.topics.slice(1), ...this.args].join(', ')});`\n            : 'log(' +\n                  (this.mem\n                      ? [...this.topics, `memory[${this.mem.offset}:${this.mem.size} ]`].join(\n                            ', '\n                        ) + 'ii'\n                      : [...this.topics, ...this.args].join(', ')) +\n                  ');';\n    }\n}\n\nexport const LOGS = (events: IEvents) => {\n    return {\n        LOG0: log(0, events),\n        LOG1: log(1, events),\n        LOG2: log(2, events),\n        LOG3: log(3, events),\n        LOG4: log(4, events),\n    };\n};\n\nfunction log(topicsCount: number, { events }: IEvents) {\n    return ({ stack, memory, stmts }: State<Inst, Expr>): void => {\n        let offset = stack.pop();\n        let size = stack.pop();\n\n        const topics = [];\n        for (let i = 0; i < topicsCount; i++) {\n            topics.push(stack.pop());\n        }\n\n        let event: IEvents['events'][string] | undefined = undefined;\n        if (topics.length > 0 && topics[0].isVal()) {\n            const eventTopic = topics[0].val.toString(16).padStart(64, '0');\n            event = events[eventTopic];\n            if (event === undefined) {\n                event = { indexedCount: topics.length - 1 };\n                events[eventTopic] = event;\n            }\n        }\n\n        offset = offset.eval();\n        size = size.eval();\n        stmts.push(\n            offset.isVal() && size.isVal()\n                ? (() => {\n                      const args = [];\n                      for (let i = Number(offset.val); i < Number(offset.val + size.val); i += 32) {\n                          args.push(i in memory ? memory[i] : new MLoad(new Val(BigInt(i))));\n                      }\n                      return new Log(event, topics, args);\n                  })()\n                : new Log(event, topics, [], { offset, size })\n        );\n    };\n}\n","import type { Stack } from '../state';\nimport { type Expr, Tag, Bin, Val } from './expr';\nimport { bin } from './math';\n\nfunction Cmp<N extends string>(tag: N, op: string) {\n    abstract class Cmp extends Tag(tag, 9) {\n        constructor(readonly left: Expr, readonly right: Expr, readonly equal: boolean = false) {\n            super();\n        }\n\n        str() {\n            return `${this.left._str(Cmp.prec)} ${\n                this.equal ? `${op}=` : `${op}`\n            } ${this.right._str(Cmp.prec)}`;\n        }\n    }\n\n    return Cmp;\n}\n\nfunction Unary<N extends string>(tag: N, op: string, prec: number) {\n    abstract class Unary extends Tag(tag, prec) {\n        constructor(readonly value: Expr) {\n            super();\n        }\n\n        str() {\n            return `${op}${this.value._str(prec)}`;\n        }\n    }\n\n    return Unary;\n}\n\nfunction Shift<N extends string>(tag: N, op: string) {\n    abstract class Shift extends Tag(tag, Byte.prec) {\n        constructor(readonly value: Expr, readonly shift: Expr) {\n            super();\n        }\n\n        str() {\n            return `${this.value._str(Shift.prec)} ${op} ${this.shift._str(Shift.prec)}`;\n        }\n    }\n\n    return Shift;\n}\n\nexport class Lt extends Cmp('Lt', '<') {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal() ? new Val(lhs.val < rhs.val ? 1n : 0n) : new Lt(lhs, rhs);\n    }\n}\n\nexport class Gt extends Cmp('Gt', '>') {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal() ? new Val(lhs.val > rhs.val ? 1n : 0n) : new Gt(lhs, rhs);\n    }\n}\n\nexport class Eq extends Bin('Eq', '==', 8) {\n    eval(): Expr {\n        return new Eq(this.left.eval(), this.right.eval());\n    }\n}\n\nexport class IsZero extends Tag('IsZero', Eq.prec) {\n    constructor(readonly value: Expr) {\n        super();\n    }\n    eval(): Expr {\n        const val = this.value.eval();\n        return val.isVal()\n            ? val.val === 0n\n                ? new Val(1n)\n                : new Val(0n)\n            : val.tag === 'Lt'\n            ? new Gt(val.left, val.right, !val.equal)\n            : val.tag === 'Gt'\n            ? new Lt(val.left, val.right, !val.equal)\n            : val.tag === 'IsZero'\n            ? val.value\n            : new IsZero(val);\n    }\n    str(): string {\n        return this.value.tag === 'Eq'\n            ? this.value.left._str(IsZero.prec) + ' != ' + this.value.right._str(IsZero.prec)\n            : this.value._str(IsZero.prec) + ' == 0';\n    }\n}\n\nexport class And extends Bin('And', '&&', 4) {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal()\n            ? new Val(lhs.val & rhs.val)\n            : lhs.isVal() && /^[f]+$/.test(lhs.val.toString(16))\n            ? rhs\n            : rhs.isVal() && /^[f]+$/.test(rhs.val.toString(16))\n            ? lhs\n            : lhs.isVal() && rhs.tag === 'And' && rhs.left.isVal() && lhs.val === rhs.left.val\n            ? rhs.right\n            : new And(lhs, rhs);\n    }\n}\n\nexport class Or extends Bin('Or', '||', 3) {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal() ? new Val(lhs.val | rhs.val) : new Or(lhs, rhs);\n    }\n}\n\nexport class Xor extends Bin('Xor', '^', 6) {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal() ? new Val(lhs.val ^ rhs.val) : new Xor(lhs, rhs);\n    }\n}\n\nexport class Not extends Unary('Not', '~', 14) {\n    eval(): Expr {\n        const val = this.value.eval();\n        return val.isVal() ? new Val(~val.val) : new Not(val);\n    }\n}\n\nexport class Byte extends Tag('Byte', 10) {\n    constructor(readonly pos: Expr, readonly data: Expr) {\n        super();\n    }\n    eval(): Expr {\n        const pos = this.pos.eval();\n        const data = this.data.eval();\n        return data.isVal() && pos.isVal()\n            ? new Val((data.val >> pos.val) & 1n)\n            : new Byte(pos, data);\n    }\n    str(): string {\n        return `(${this.data._str(Byte.prec)} >> ${this.pos._str(Byte.prec)}) & 1`;\n    }\n}\n\nexport class Shl extends Shift('Shl', '<<') {\n    eval(): Expr {\n        const val = this.value.eval();\n        const shift = this.shift.eval();\n        return val.isVal() && shift.isVal() ? new Val(val.val << shift.val) : new Shl(val, shift);\n    }\n}\n\nexport class Shr extends Shift('Shr', '>>>') {\n    eval(): Expr {\n        const val = this.value.eval();\n        const shift = this.shift.eval();\n        return val.isVal() && shift.isVal() ? new Val(val.val >> shift.val) : new Shr(val, shift);\n    }\n}\n\nexport class Sar extends Shift('Sar', '>>') {\n    eval(): Expr {\n        const val = this.value.eval();\n        const shift = this.shift.eval();\n        return val.isVal() && shift.isVal() ? new Val(val.val >> shift.val) : new Sar(val, shift);\n    }\n}\n\nexport class Sig extends Tag('Sig', Eq.prec) {\n    constructor(readonly selector: string) {\n        super();\n    }\n    eval(): Expr {\n        return this;\n    }\n    str(): string {\n        return `msg.sig == ${this.selector}`;\n    }\n}\n\nfunction fromSHRsig(left: Expr, right: Expr, cc: () => Sig | Eq) {\n    if (\n        left.isVal() &&\n        right.tag === 'Shr' &&\n        right.shift.isVal() &&\n        right.shift.val === 0xe0n &&\n        right.value.tag === 'CallDataLoad' &&\n        right.value.location.isZero()\n    ) {\n        return new Sig(left.val.toString(16).padStart(8, '0'));\n    }\n    return cc();\n}\n\nfunction fromDIVEXPsig(left: Expr, right: Expr, cc: () => Sig | Eq) {\n    left = left.eval();\n    right = right.eval();\n\n    if (left.isVal() && right.tag === 'Div' && right.right.isVal()) {\n        const selector = left.val * right.right.val;\n        right = right.left;\n\n        if (\n            selector % (1n << 0xe0n) === 0n &&\n            right.tag === 'CallDataLoad' &&\n            right.location.isZero()\n        ) {\n            return new Sig(\n                selector\n                    .toString(16)\n                    .substring(0, 8 - (64 - selector.toString(16).length))\n                    .padStart(8, '0')\n            );\n        }\n    }\n\n    return cc();\n}\n\nfunction eqHook(left: Expr, right: Expr, cc: () => Eq) {\n    return fromDIVEXPsig(left, right, () =>\n        fromDIVEXPsig(right, left, () => fromSHRsig(left, right, () => fromSHRsig(right, left, cc)))\n    );\n}\n\nexport const LOGIC = {\n    LT: bin(Lt),\n    GT: bin(Gt),\n    SLT: bin(Lt),\n    SGT: bin(Gt),\n\n    EQ: (stack: Stack<Expr>): void => {\n        const left = stack.pop();\n        const right = stack.pop();\n\n        stack.push(\n            left.isVal() && right.isVal()\n                ? left.val === right.val\n                    ? new Val(1n)\n                    : new Val(0n)\n                : eqHook(left, right, () => new Eq(left, right))\n        );\n    },\n\n    ISZERO: (stack: Stack<Expr>): void => {\n        const value = stack.pop();\n        stack.push(new IsZero(value));\n    },\n\n    AND: bin(And),\n    OR: bin(Or),\n    XOR: bin(Xor),\n    NOT: (stack: Stack<Expr>): void => {\n        const value = stack.pop();\n        stack.push(new Not(value));\n    },\n\n    BYTE: (stack: Stack<Expr>): void => {\n        const position = stack.pop();\n        const data = stack.pop();\n        stack.push(new Byte(position, data));\n    },\n\n    SHL: shift(Shl),\n    SHR: shift(Shr),\n    SAR: shift(Sar),\n};\n\nexport function shift(Cons: new (value: Expr, shift: Expr) => Expr): (stack: Stack<Expr>) => void {\n    return function (stack: Stack<Expr>) {\n        const shift = stack.pop();\n        const value = stack.pop();\n        stack.push(new Cons(value, shift));\n    };\n}\n","import type { Stack } from '../state';\nimport { Bin, type Expr, Val } from './expr';\nimport { Sar, Shl } from './logic';\n\nexport class Add extends Bin('Add', '+', 11) {\n    eval(): Expr {\n        const left = this.left.eval();\n        const right = this.right.eval();\n        return left.isVal() && right.isVal()\n            ? new Val(left.val + right.val)\n            : left.isZero()\n            ? right\n            : right.isZero()\n            ? left\n            : new Add(left, right);\n    }\n}\n\nexport class Mul extends Bin('Mul', '*', 12) {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal()\n            ? new Val(lhs.val * rhs.val)\n            : lhs.isZero() || rhs.isZero()\n            ? new Val(0n)\n            : new Mul(lhs, rhs);\n    }\n}\n\nexport class Sub extends Bin('Sub', '-', Add.prec) {\n    eval(): Expr {\n        const left = this.left.eval();\n        const right = this.right.eval();\n        return left.isVal() && right.isVal()\n            ? new Val(left.val - right.val)\n            : right.isZero()\n            ? left\n            : new Sub(left, right);\n    }\n}\n\nexport class Div extends Bin('Div', '/', Mul.prec) {\n    eval(): Expr {\n        const left = this.left.eval();\n        const right = this.right.eval();\n        return left.isVal() && right.isVal()\n            ? right.val === 0n\n                ? new Div(left, right)\n                : new Val(left.val / right.val)\n            : right.isVal() && right.val === 1n\n            ? left\n            : new Div(left, right);\n    }\n}\n\nexport class Mod extends Bin('Mod', '%', Mul.prec) {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal() ? new Val(lhs.val % rhs.val) : new Mod(lhs, rhs);\n    }\n}\n\nexport class Exp extends Bin('Exp', '**', 14) {\n    eval(): Expr {\n        const left = this.left.eval();\n        const right = this.right.eval();\n        return left.isVal() && right.isVal() && right.val >= 0\n            ? new Val(left.val ** right.val)\n            : new Exp(left, right);\n    }\n}\n\nexport const MATH = {\n    ADD: bin(Add),\n    MUL: bin(Mul),\n    SUB: bin(Sub),\n    DIV: bin(Div),\n    SDIV: bin(Div),\n    MOD: bin(Mod),\n    SMOD: bin(Mod),\n\n    ADDMOD: (stack: Stack<Expr>): void => {\n        const left = stack.pop();\n        const right = stack.pop();\n        const mod = stack.pop();\n        stack.push(\n            left.isVal() && right.isVal() && mod.isVal()\n                ? new Val((left.val + right.val) % mod.val)\n                : left.isVal() && right.isVal()\n                ? new Mod(new Val(left.val + right.val), mod)\n                : new Mod(new Add(left, right), mod)\n        );\n    },\n\n    MULMOD: (stack: Stack<Expr>): void => {\n        const left = stack.pop();\n        const right = stack.pop();\n        const mod = stack.pop();\n        stack.push(\n            left.isVal() && right.isVal() && mod.isVal()\n                ? new Val((left.val * right.val) % mod.val)\n                : left.isVal() && right.isVal()\n                ? new Mod(new Val(left.val * right.val), mod)\n                : new Mod(new Mul(left, right), mod)\n        );\n    },\n\n    EXP: bin(Exp),\n\n    SIGNEXTEND: (stack: Stack<Expr>): void => {\n        const left = stack.pop();\n        const right = stack.pop();\n        stack.push(\n            left.isVal() && right.isVal()\n                ? new Val((right.val << (32n - left.val)) >> (32n - left.val))\n                : left.isVal()\n                ? new Sar(new Shl(right, new Val(32n - left.val)), new Val(32n - left.val))\n                : new Sar(new Shl(right, new Sub(new Val(32n), left)), new Sub(new Val(32n), left))\n        );\n    },\n};\n\nexport function bin(Cons: new (lhs: Expr, rhs: Expr) => Expr): (stack: Stack<Expr>) => void {\n    return function (stack: Stack<Expr>) {\n        const lhs = stack.pop();\n        const rhs = stack.pop();\n        stack.push(new Cons(lhs, rhs));\n    };\n}\n","import type { State } from '../state';\nimport { type Inst, Tag, type Expr, type IInst } from './expr';\n\nexport class MLoad extends Tag('MLoad') {\n    /**\n     * Loads word from memory.\n     *\n     * @param loc\n     */\n    constructor(readonly loc: Expr) {\n        super();\n    }\n\n    eval(): this {\n        return this;\n    }\n\n    str(): string {\n        return `memory[${this.loc}]`;\n    }\n}\n\nexport class MStore implements IInst {\n    readonly name = 'MStore';\n\n    constructor(readonly location: Expr, readonly data: Expr) {}\n\n    eval() {\n        return this;\n    }\n\n    toString(): string {\n        return `memory[${this.location}] = ${this.data};`;\n    }\n}\n\nexport const MEMORY = {\n    MLOAD: ({ stack, memory }: State<Inst, Expr>): void => {\n        let loc = stack.pop();\n        loc = loc.eval();\n        stack.push(\n            loc.isVal() && Number(loc.val) in memory ? memory[Number(loc.val)] : new MLoad(loc)\n        );\n    },\n    MSTORE: mstore,\n    MSTORE8: mstore,\n};\n\nfunction mstore({ stack, memory, stmts }: State<Inst, Expr>): void {\n    let loc = stack.pop();\n    const data = stack.pop();\n\n    loc = loc.eval();\n    if (loc.isVal()) {\n        memory[Number(loc.val)] = data;\n    } else {\n        stmts.push(new MStore(loc, data));\n    }\n}\n","import { type Expr, Val } from './expr';\nimport { toHex } from '../opcode';\nimport { type Stack } from '../state';\n\nexport const PUSHES = {\n    PUSH1: push,\n    PUSH2: push,\n    PUSH3: push,\n    PUSH4: push,\n    PUSH5: push,\n    PUSH6: push,\n    PUSH7: push,\n    PUSH8: push,\n    PUSH9: push,\n    PUSH10: push,\n    PUSH11: push,\n    PUSH12: push,\n    PUSH13: push,\n    PUSH14: push,\n    PUSH15: push,\n    PUSH16: push,\n    PUSH17: push,\n    PUSH18: push,\n    PUSH19: push,\n    PUSH20: push,\n    PUSH21: push,\n    PUSH22: push,\n    PUSH23: push,\n    PUSH24: push,\n    PUSH25: push,\n    PUSH26: push,\n    PUSH27: push,\n    PUSH28: push,\n    PUSH29: push,\n    PUSH30: push,\n    PUSH31: push,\n    PUSH32: push,\n};\n\nfunction push(pushData: Uint8Array, stack: Stack<Expr>): void {\n    stack.push(new Val(BigInt('0x' + toHex(pushData)), true));\n}\n\nexport function STACK<E>() {\n    return {\n        POP: (stack: Stack<Expr>): void => void stack.pop(),\n        DUP1: dup(0),\n        DUP2: dup(1),\n        DUP3: dup(2),\n        DUP4: dup(3),\n        DUP5: dup(4),\n        DUP6: dup(5),\n        DUP7: dup(6),\n        DUP8: dup(7),\n        DUP9: dup(8),\n        DUP10: dup(9),\n        DUP11: dup(10),\n        DUP12: dup(11),\n        DUP13: dup(12),\n        DUP14: dup(13),\n        DUP15: dup(14),\n        DUP16: dup(15),\n        SWAP1: swap(1),\n        SWAP2: swap(2),\n        SWAP3: swap(3),\n        SWAP4: swap(4),\n        SWAP5: swap(5),\n        SWAP6: swap(6),\n        SWAP7: swap(7),\n        SWAP8: swap(8),\n        SWAP9: swap(9),\n        SWAP10: swap(10),\n        SWAP11: swap(11),\n        SWAP12: swap(12),\n        SWAP13: swap(13),\n        SWAP14: swap(14),\n        SWAP15: swap(15),\n        SWAP16: swap(16),\n    };\n\n    function dup(position: number) {\n        return (stack: Stack<E>): void => stack.dup(position);\n    }\n\n    function swap(position: number) {\n        return (stack: Stack<E>): void => stack.swap(position);\n    }\n}\n","import type { State } from '../state';\nimport { type Expr, type IInst, type Inst, Tag } from './expr';\nimport type { Sha3 } from './system';\n\nexport interface IStore {\n    /**\n     * vars definition\n     */\n    readonly variables: { [location: string]: Variable };\n\n    /**\n     * mappings definition\n     */\n    readonly mappings: {\n        [location: string]: {\n            name: string | undefined;\n            structs: bigint[];\n            keys: Expr[][];\n            values: Expr[];\n        };\n    };\n}\n\n/**\n *\n */\nexport class Variable {\n    constructor(public label: string | undefined, readonly types: Expr[]) {}\n}\n\n/**\n *\n * @param variables\n * @returns\n */\nexport function stringifyVariables(variables: IStore['variables']) {\n    let output = '';\n    Object.entries(variables).forEach(([hash, variable], index) => {\n        const types: string[] = variable.types\n            .map(expr => expr.eval())\n            .map(expr => (!expr.isVal() ? '???expr.type' ?? '' : 'bigint'))\n            .filter(t => t.trim() !== '');\n        if (types.length === 0) {\n            types.push('unknown');\n        }\n        const name = variable.label ? ` public ${variable.label}` : ` var${index + 1}`;\n        output += [...new Set(types)].join('|') + name + '; // #' + hash;\n        output += '\\n';\n    });\n\n    if (Object.keys(variables).length > 0) {\n        output += '\\n';\n    }\n\n    return output;\n}\n\n/**\n *\n * @param mappings\n * @returns\n */\nexport function stringifyStructs(mappings: IStore['mappings']) {\n    let text = '';\n\n    Object.keys(mappings)\n        .filter(key => mappings[key].structs.length > 0)\n        .forEach(key => {\n            const mapping = mappings[key];\n            text += `struct ${mapping.name}Struct {\\n`;\n            mapping.structs.forEach(struct => {\n                text += `    ${struct.toString()};\\n`;\n            });\n            text += '}\\n\\n';\n        });\n\n    return text;\n}\n\n/**\n *\n * @param mappings\n * @returns\n */\nexport function stringifyMappings(mappings: IStore['mappings']) {\n    let output = '';\n\n    Object.keys(mappings).forEach((key: string, index: number) => {\n        const mapping = mappings[key];\n        if (mapping.name) {\n            output += stringifyMapping(mapping) + ' public ' + mapping.name + ';';\n        } else {\n            output += stringifyMapping(mapping) + ` mapping${index + 1};`;\n        }\n        output += '\\n';\n    });\n\n    if (Object.keys(mappings).length > 0) {\n        output += '\\n';\n    }\n\n    return output;\n\n    function stringifyMapping(mapping: IStore['mappings'][keyof IStore['mappings']]) {\n        const mappingKey: string[] = [];\n        const mappingValue: string[] = [];\n        let deepMapping = false;\n        mapping.keys\n            .filter(mappingChild => mappingChild.length > 0)\n            .forEach(mappingChild => {\n                const mappingChild0 = mappingChild[0];\n                if (\n                    mappingChild.length > 0 &&\n                    mappingChild0.type &&\n                    !mappingKey.includes(mappingChild0.type)\n                ) {\n                    mappingKey.push(mappingChild0.type);\n                }\n                if (mappingChild.length > 1 && !deepMapping) {\n                    deepMapping = true;\n                    mappingValue.push(\n                        stringifyMapping({\n                            name: mapping.name,\n                            structs: mapping.structs,\n                            keys: mapping.keys.map(items => {\n                                items.shift();\n                                return items;\n                            }),\n                            values: mapping.values,\n                        })\n                    );\n                } else if (mappingChild.length === 1 && !deepMapping) {\n                    mapping.values.forEach(mappingChild2 => {\n                        if (mappingChild2.type && !mappingValue.includes(mappingChild2.type)) {\n                            mappingValue.push(mappingChild2.type);\n                        }\n                    });\n                }\n            });\n        if (mappingKey.length === 0) {\n            mappingKey.push('unknown');\n        }\n        if (mapping.structs.length > 0 && mappingValue.length === 0) {\n            mappingValue.push(`${mapping.name}Struct`);\n        } else if (mappingValue.length === 0) {\n            mappingValue.push('unknown');\n        }\n        return 'mapping (' + mappingKey.join('|') + ' => ' + mappingValue.join('|') + ')';\n    }\n}\n\nexport class MappingStore implements IInst {\n    readonly name = 'MappingStore';\n\n    constructor(\n        readonly mappings: IStore['mappings'],\n        readonly location: number,\n        readonly items: Expr[],\n        readonly data: Expr,\n        readonly structlocation?: bigint\n    ) {\n        const loc = location;\n        if (!(loc in mappings)) {\n            mappings[loc] = { name: undefined, structs: [], keys: [], values: [] };\n        }\n        mappings[loc].keys.push(items);\n        if (structlocation === undefined) {\n            mappings[loc].values.push(data);\n        }\n    }\n\n    eval() {\n        return this;\n    }\n\n    toString() {\n        let mappingName = `mapping${this.location + 1}`;\n        if (this.location in this.mappings && this.mappings[this.location].name) {\n            mappingName = this.mappings[this.location].name!;\n        }\n\n        if (\n            this.data.tag === 'Add' &&\n            this.data.right.tag === 'MappingLoad' &&\n            this.data.right.location === this.location\n        ) {\n            return (\n                mappingName +\n                this.items.map(item => '[' + item.str() + ']').join('') +\n                ' += ' +\n                this.data.left.str() +\n                ';'\n            );\n        } else if (\n            this.data.tag === 'Add' &&\n            this.data.left.tag === 'MappingLoad' &&\n            this.data.left.location === this.location\n        ) {\n            return (\n                mappingName +\n                this.items.map(item => '[' + item.str() + ']').join('') +\n                ' += ' +\n                this.data.right.str() +\n                ';'\n            );\n        } else if (\n            this.data.tag === 'Sub' &&\n            this.data.left.tag === 'MappingLoad' &&\n            this.data.left.location === this.location\n        ) {\n            return (\n                mappingName +\n                this.items.map(item => '[' + item.str() + ']').join('') +\n                ' -= ' +\n                this.data.right.str() +\n                ';'\n            );\n        } else {\n            return (\n                mappingName +\n                this.items.map(item => `[${item.str()}]`).join('') +\n                ' = ' +\n                this.data.str() +\n                ';'\n            );\n        }\n    }\n}\n\nexport class SStore {\n    readonly name = 'SStore';\n\n    constructor(\n        readonly location: Expr,\n        readonly data: Expr,\n        readonly variables: IStore['variables']\n    ) {\n        // if (isVal(this.location)) {\n        //     const loc = this.location.toString();\n        //     if (loc in this.variables) {\n        //         this.variables[loc].types.push(this.data.type);\n        //     } else {\n        //         this.variables[loc] = new Variable(undefined, [this.data.type]);\n        //     }\n        // }\n    }\n\n    eval() {\n        return new SStore(this.location.eval(), this.data.eval(), this.variables);\n    }\n\n    toString() {\n        let variableName = 'storage[' + this.location.str() + ']';\n        if (this.location.isVal() && this.location.val.toString() in this.variables) {\n            const loc = this.location.val.toString();\n            const label = this.variables[loc].label;\n            if (label) {\n                variableName = label;\n            } else {\n                variableName = `var${Object.keys(this.variables).indexOf(loc) + 1}`;\n            }\n        }\n        if (\n            this.data.tag === 'Add' &&\n            this.data.left.tag === 'SLoad' &&\n            this.data.left.location.str() === this.location.str()\n        ) {\n            return variableName + ' += ' + this.data.right.str() + ';';\n        } else if (\n            this.data.tag === 'Sub' &&\n            this.data.left.tag === 'SLoad' &&\n            this.data.left.location.str() === this.location.str()\n        ) {\n            return variableName + ' -= ' + this.data.right.str() + ';';\n        } else {\n            return variableName + ' = ' + this.data.str() + ';';\n        }\n    }\n}\n\nexport class MappingLoad extends Tag('MappingLoad') {\n    constructor(\n        readonly mappings: IStore['mappings'],\n        readonly location: number,\n        readonly items: Expr[],\n        readonly structlocation?: bigint\n    ) {\n        super();\n        if (!(location in mappings)) {\n            mappings[location] = {\n                name: undefined,\n                structs: [],\n                keys: [],\n                values: [],\n            };\n        }\n        mappings[location].keys.push(items);\n    }\n\n    eval() {\n        return this;\n    }\n\n    str(): string {\n        let mappingName = `mapping${this.location + 1}`;\n        const maybeName = this.mappings[this.location].name;\n        if (this.location in this.mappings && maybeName) {\n            mappingName = maybeName;\n        }\n        if (this.structlocation) {\n            return (\n                mappingName +\n                this.items.map(item => `[${item.str()}]`).join('') +\n                '[' +\n                this.structlocation.toString() +\n                ']'\n            );\n        } else {\n            return mappingName + this.items.map(item => '[' + item.str() + ']').join('');\n        }\n    }\n}\n\nexport class SLoad extends Tag('SLoad') {\n    constructor(readonly location: Expr, readonly variables: IStore['variables']) {\n        super();\n    }\n\n    eval(): Expr {\n        return new SLoad(this.location.eval(), this.variables);\n    }\n\n    str(): string {\n        if (this.location.isVal() && this.location.val.toString() in this.variables) {\n            const loc = this.location.val.toString();\n            const label = this.variables[loc].label;\n            if (label) {\n                return label;\n            } else {\n                return `var${Object.keys(this.variables).indexOf(loc) + 1}`;\n            }\n        } else {\n            return 'storage[' + this.location.str() + ']';\n        }\n    }\n}\n\nfunction parseSha3(sha: Sha3): [number | undefined, Expr[]] {\n    const shas = [sha];\n    const mappings = [];\n    let base = undefined;\n    while (shas.length > 0) {\n        const sha = shas.shift()!;\n        for (const arg of sha.args) {\n            if (arg.tag === 'Sha3' && arg.args) {\n                shas.unshift(arg);\n            } else if (base === undefined && arg.tag === 'Val') {\n                base = Number(arg.val);\n            } else {\n                mappings.unshift(arg);\n            }\n        }\n    }\n    return [base, mappings];\n}\n\nexport const STORAGE = ({ variables, mappings }: IStore) => {\n    return {\n        SLOAD: ({ stack }: State<Inst, Expr>): void => {\n            const loc = stack.pop();\n\n            if (loc.tag === 'Sha3') {\n                const [base, parts] = parseSha3(loc);\n                if (base !== undefined && parts.length > 0) {\n                    stack.push(new MappingLoad(mappings, base, parts));\n                } else {\n                    stack.push(new SLoad(loc, variables));\n                }\n            } else if (loc.tag === 'Add' && loc.left.tag === 'Sha3' && loc.right.isVal()) {\n                const [base, parts] = parseSha3(loc.left);\n                if (base !== undefined && parts.length > 0) {\n                    stack.push(new MappingLoad(mappings, base, parts, loc.right.val));\n                } else {\n                    stack.push(new SLoad(loc, variables));\n                }\n            } else if (loc.tag === 'Add' && loc.left.isVal() && loc.right.tag === 'Sha3') {\n                const [base, parts] = parseSha3(loc.right);\n                if (base !== undefined && parts.length > 0) {\n                    stack.push(new MappingLoad(mappings, base, parts, loc.left.val));\n                } else {\n                    stack.push(new SLoad(loc, variables));\n                }\n            } else {\n                stack.push(new SLoad(loc, variables));\n            }\n        },\n\n        SSTORE: ({ stack, stmts }: State<Inst, Expr>): void => {\n            const loc = stack.pop();\n            const data = stack.pop();\n\n            if (loc.isVal()) {\n                sstoreVariable();\n            } else if (loc.tag === 'Sha3') {\n                const [base, parts] = parseSha3(loc);\n                if (base !== undefined && parts.length > 0) {\n                    stmts.push(new MappingStore(mappings, base, parts, data));\n                } else {\n                    sstoreVariable();\n                }\n            } else if (loc.tag === 'Add' && loc.left.tag === 'Sha3' && loc.right.isVal()) {\n                const [base, parts] = parseSha3(loc.left);\n                if (base !== undefined && parts.length > 0) {\n                    stmts.push(new MappingStore(mappings, base, parts, data, loc.right.val));\n                } else {\n                    sstoreVariable();\n                }\n            } else if (loc.tag === 'Add' && loc.left.isVal() && loc.right.tag === 'Sha3') {\n                const [base, parts] = parseSha3(loc.right);\n                if (base !== undefined && parts.length > 0) {\n                    stmts.push(new MappingStore(mappings, base, parts, data, loc.left.val));\n                } else {\n                    sstoreVariable();\n                }\n            } else {\n                sstoreVariable();\n            }\n\n            function sstoreVariable() {\n                if (loc.isVal()) {\n                    const key = loc.val.toString();\n                    if (key in variables) {\n                        variables[key].types.push(data);\n                    } else {\n                        variables[key] = new Variable(undefined, [data]);\n                    }\n                }\n                stmts.push(new SStore(loc, data, variables));\n            }\n        },\n    };\n};\n","import type { Ram } from '../state';\nimport { type Expr, Tag, Val } from './expr';\n\nexport const INFO = {\n    ADDRESS: 'this',\n    ORIGIN: 'tx.origin',\n    CALLER: 'msg.sender',\n    CODESIZE: 'this.code.length',\n    GASPRICE: 'tx.gasprice',\n    RETURNDATASIZE: 'output.length',\n    COINBASE: 'block.coinbase',\n    TIMESTAMP: 'block.timestamp',\n    NUMBER: 'block.number',\n    DIFFICULTY: 'block.difficulty',\n    GASLIMIT: 'block.gaslimit',\n    CHAINID: 'chainid',\n    SELFBALANCE: 'self.balance',\n    MSIZE: 'memory.length',\n    GAS: 'gasleft()',\n} as const;\n\nexport type Info = (typeof INFO)[keyof typeof INFO];\n\nexport class Symbol0 extends Tag('Symbol0') {\n    constructor(readonly symbol: Info, readonly type2?: string | undefined) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return this.symbol;\n    }\n}\n\nexport class Symbol1 extends Tag('Symbol1') {\n    constructor(readonly fn: (value: string) => string, readonly value: Expr) {\n        super();\n    }\n\n    eval(): Expr {\n        return new Symbol1(this.fn, this.value.eval());\n    }\n\n    str(): string {\n        return this.fn(this.value._str(Val.prec));\n    }\n}\n\nexport class DataCopy extends Tag('DataCopy') {\n    constructor(\n        readonly fn: (offset: string, size: string) => string,\n        readonly offset: Expr,\n        readonly size: Expr\n    ) {\n        super();\n    }\n\n    eval(): this {\n        return this;\n    }\n\n    str(): string {\n        return this.fn(this.offset.str(), this.size.str());\n    }\n}\n\nexport const SYM = {\n    ...(Object.fromEntries(Object.entries(INFO).map(([name, value]) => [name, symbol0(value)])) as {\n        [name in keyof typeof INFO]: ReturnType<typeof symbol0>;\n    }),\n    // ADDRESS: symbol0('this', 'address'),\n    BALANCE: symbol1(address => `${address}.balance`),\n    // ORIGIN: symbol0('tx.origin'),\n    // CALLER: symbol0('msg.sender'),\n    CALLDATACOPY: datacopy((offset, size) => `msg.data[${offset}:(${offset}+${size})];`),\n    // CODESIZE: symbol0('this.code.length'),\n    CODECOPY: datacopy((offset, size) => `this.code[${offset}:(${offset}+${size})]`),\n    // GASPRICE: symbol0('tx.gasprice'),\n    EXTCODESIZE: symbol1(address => `address(${address}).code.length`),\n    EXTCODECOPY: ({ stack }: Ram<Expr>): void => {\n        const address = stack.pop();\n        datacopy((offset, size) => `address(${address.str()}).code[${offset}:(${offset}+${size})]`);\n    },\n    // RETURNDATASIZE: symbol0('output.length'),\n    RETURNDATACOPY: datacopy((offset, size) => `output[${offset}:(${offset}+${size})]`),\n    EXTCODEHASH: symbol1(address => `keccak256(address(${address}).code)`),\n\n    // Block Information\n    BLOCKHASH: symbol1(blockNumber => `blockhash(${blockNumber})`),\n    // COINBASE: symbol0('block.coinbase'),\n    // TIMESTAMP: symbol0('block.timestamp'),\n    // NUMBER: symbol0('block.number'),\n    // DIFFICULTY: symbol0('block.difficulty'),\n    // GASLIMIT: symbol0('block.gaslimit'),\n    // CHAINID: symbol0('chainid'),\n    // SELFBALANCE: symbol0('self.balance'),\n    // MSIZE: symbol0('memory.length'),\n    // GAS: symbol0('gasleft()'),\n};\n\nfunction symbol0(value: Info, type?: string) {\n    return ({ stack }: Ram<Expr>) => {\n        stack.push(new Symbol0(value, type));\n    };\n}\n\nfunction symbol1(fn: (value: string) => string) {\n    return ({ stack }: Ram<Expr>) => {\n        const value = stack.pop();\n        stack.push(new Symbol1(fn, value));\n    };\n}\n\nexport function datacopy(fn: (offset: string, size: string) => string) {\n    return ({ stack, memory }: Ram<Expr>): void => {\n        const dest = stack.pop();\n        const offset = stack.pop();\n        const size = stack.pop();\n        if (!dest.isVal()) {\n            // throw new Error('expected number in returndatacopy');\n        } else {\n            memory[Number(dest.val)] = new DataCopy(fn, offset, size);\n        }\n    };\n}\n","import type { Opcode } from '../opcode';\nimport type { State } from '../state';\nimport { type IInst, Tag, Val, type Expr, type Inst } from './expr';\nimport { MLoad } from './memory';\n\nexport class Sha3 extends Tag('Sha3') {\n    constructor(readonly args: Expr[], readonly memoryStart?: Expr, readonly memoryLength?: Expr) {\n        super();\n    }\n\n    eval(): Expr {\n        return new Sha3(\n            this.args.map(e => e.eval()),\n            this.memoryStart,\n            this.memoryLength\n        );\n    }\n\n    str(): string {\n        return this.memoryStart && this.memoryLength\n            ? `keccak256(memory[${this.memoryStart}:(${this.memoryStart}+${this.memoryLength})])`\n            : `keccak256(${this.args.join(', ')})`;\n    }\n}\n\nexport class Create extends Tag('Create') {\n    override readonly type = 'address';\n\n    /**\n     * Creates a new account with associated code.\n     *\n     * @param value Value in _wei_ to send to the new account.\n     * @param offset Byte offset in the memory in bytes, the initialisation code for the new account.\n     * @param size Byte size to copy (size of the initialisation code).\n     */\n    constructor(readonly value: Expr, readonly offset: Expr, readonly size: Expr) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return `new Contract(memory[${this.offset}..${this.offset}+${this.size}]).value(${this.value}).address`;\n    }\n}\n\nexport class Call extends Tag('Call') {\n    throwOnFail = false;\n\n    constructor(\n        readonly gas: Expr,\n        readonly address: Expr,\n        readonly value: Expr,\n        readonly memoryStart: Expr,\n        readonly memoryLength: Expr,\n        readonly outputStart: Expr,\n        readonly outputLength: Expr\n    ) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        if (this.memoryLength.isZero() && this.outputLength.isZero()) {\n            if (\n                this.gas.tag === 'Mul' &&\n                this.gas.left.isZero() &&\n                this.gas.right.isVal() &&\n                this.gas.right.val === 2300n\n            ) {\n                if (this.throwOnFail) {\n                    return `address(${this.address}).transfer(${this.value})`;\n                } else {\n                    return `address(${this.address}).send(${this.value})`;\n                }\n            } else {\n                return `address(${this.address}).call.gas(${this.gas}).value(${this.value})`;\n            }\n        } else {\n            return `call(${this.gas},${this.address},${this.value},${this.memoryStart},${this.memoryLength},${this.outputStart},${this.outputLength})`;\n        }\n    }\n}\n\nexport class ReturnData extends Tag('ReturnData') {\n    readonly name = 'ReturnData';\n    override readonly type?: string;\n    readonly wrapped = false;\n\n    constructor(readonly retOffset: any, readonly retSize: any) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n    str(): string {\n        return `output:ReturnData:${this.retOffset}:${this.retSize}`;\n    }\n}\n\nexport class CallCode extends Tag('CallCode') {\n    readonly name = 'CallCode';\n\n    constructor(\n        readonly gas: Expr,\n        readonly address: Expr,\n        readonly value: Expr,\n        readonly memoryStart: Expr,\n        readonly memoryLength: Expr,\n        readonly outputStart: Expr,\n        readonly outputLength: Expr\n    ) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return `callcode(${this.gas},${this.address},${this.value},${this.memoryStart},${this.memoryLength},${this.outputStart},${this.outputLength})`;\n    }\n}\n\nexport class Create2 extends Tag('Create2') {\n    constructor(readonly offset: Expr, readonly size: Expr, readonly value: Expr) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return `new Contract(memory[${this.offset}:(${this.offset}+${this.size})]).value(${this.value}).address`;\n    }\n}\n\nexport class StaticCall extends Tag('StaticCall') {\n    constructor(\n        readonly gas: Expr,\n        readonly address: Expr,\n        readonly memoryStart: Expr,\n        readonly memoryLength: Expr,\n        readonly outputStart: Expr,\n        readonly outputLength: Expr\n    ) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return `staticcall(${this.gas},${this.address},${this.memoryStart},${this.memoryLength},${this.outputStart},${this.outputLength})`;\n    }\n}\n\nexport class DelegateCall extends Tag('DelegateCall') {\n    constructor(\n        readonly gas: Expr,\n        readonly address: Expr,\n        readonly memoryStart: Expr,\n        readonly memoryLength: Expr,\n        readonly outputStart: Expr,\n        readonly outputLength: Expr\n    ) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return `delegatecall(${this.gas},${this.address},${this.memoryStart},${this.memoryLength},${this.outputStart},${this.outputLength})`;\n    }\n}\n\nexport class Stop implements IInst {\n    readonly name = 'Stop';\n\n    eval() {\n        return this;\n    }\n\n    toString() {\n        return 'return;';\n    }\n}\n\nexport class Return implements IInst {\n    readonly name = 'Return';\n\n    /**\n     * Exits the current context successfully.\n     *\n     * @param args\n     * @param offset Byte offset in the memory in bytes, to copy what will be the return data of this context.\n     * @param size Byte size to copy (size of the return data).\n     */\n    constructor(readonly args: Expr[], readonly offset?: Expr, readonly size?: Expr) {}\n\n    eval() {\n        return this;\n    }\n\n    toString(): string {\n        if (this.offset && this.size) {\n            return `return memory[${this.offset}:(${this.offset}+${this.size})];`;\n        } else if (this.args.length === 0) {\n            return 'return;';\n        } else if (isStringReturn(this.args) && this.args[0].val === 32n) {\n            return `return '${hex2a(this.args[2].val.toString(16))}';`;\n        } else {\n            return this.args.length === 1\n                ? `return ${this.args[0]};`\n                : `return (${this.args.join(', ')});`;\n        }\n    }\n}\n\nfunction isStringReturn(args: Expr[]): args is [Val, Val, Val] {\n    return args.length === 3 && args.every(arg => arg.isVal());\n}\n\nfunction hex2a(hexstr: string) {\n    let str = '';\n    for (let i = 0; i < hexstr.length && hexstr.slice(i, i + 2) !== '00'; i += 2) {\n        str += String.fromCharCode(parseInt(hexstr.substring(i, i + 2), 16));\n    }\n    return str;\n}\n\nexport class Revert implements IInst {\n    readonly name = 'Revert';\n\n    constructor(readonly args: Expr[], readonly offset?: Expr, readonly size?: Expr) {}\n\n    eval() {\n        return this;\n    }\n\n    toString() {\n        return this.offset && this.size\n            ? `revert(memory[${this.offset}:(${this.offset}+${this.size})]);`\n            : `revert(${this.args.join(', ')});`;\n    }\n}\n\nexport class Invalid implements IInst {\n    readonly name = 'Invalid';\n\n    constructor(readonly reason: string) {}\n\n    eval() {\n        return this;\n    }\n\n    toString() {\n        return `revert('${this.reason}');`;\n    }\n}\n\nexport class SelfDestruct implements IInst {\n    readonly name = 'SelfDestruct';\n\n    constructor(readonly address: Expr) {}\n\n    eval() {\n        return this;\n    }\n\n    toString() {\n        return `selfdestruct(${this.address});`;\n    }\n}\n\nexport function memArgs<T>(\n    { stack, memory }: State<Inst, Expr>,\n    Klass: new (args: Expr[], offset?: Expr, size?: Expr) => T\n): T {\n    const MAXSIZE = 1024;\n\n    let offset = stack.pop();\n    let size = stack.pop();\n\n    offset = offset.eval();\n    size = size.eval();\n\n    if (offset.isVal() && size.isVal() && size.val <= MAXSIZE * 32) {\n        const args = [];\n        for (let i = Number(offset.val); i < Number(offset.val + size.val); i += 32) {\n            args.push(i in memory ? memory[i].eval() : new MLoad(new Val(BigInt(i))));\n        }\n\n        return new Klass(args);\n    } else {\n        if (size.isVal() && size.val > MAXSIZE * 32) {\n            throw new Error(`memargs size${Klass.toString()}${size.val}`);\n        }\n\n        return new Klass([], offset, size);\n    }\n}\n\nexport const SYSTEM = {\n    SHA3: (state: State<Inst, Expr>): void => state.stack.push(memArgs(state, Sha3)),\n    STOP: (state: State<Inst, Expr>): void => state.halt(new Stop()),\n\n    CREATE: ({ stack }: State<Inst, Expr>): void => {\n        const value = stack.pop();\n        const offset = stack.pop();\n        const size = stack.pop();\n        stack.push(new Create(value, offset, size));\n    },\n\n    CALL: ({ stack, memory }: State<Inst, Expr>): void => {\n        const gas = stack.pop();\n        const address = stack.pop();\n        const value = stack.pop();\n        const memoryStart = stack.pop();\n        const memoryLength = stack.pop();\n        const outputStart = stack.pop();\n        const outputLength = stack.pop();\n        stack.push(\n            new Call(gas, address, value, memoryStart, memoryLength, outputStart, outputLength)\n        );\n\n        // if (typeof outputStart !== 'number') {\n        //     console.log('WARN:CALL outstart should be number');\n        // }\n\n        memory[outputStart as any as number] = new ReturnData(outputStart, outputLength);\n    },\n    CALLCODE: ({ stack }: State<Inst, Expr>): void => {\n        const gas = stack.pop();\n        const address = stack.pop();\n        const value = stack.pop();\n        const memoryStart = stack.pop();\n        const memoryLength = stack.pop();\n        const outputStart = stack.pop();\n        const outputLength = stack.pop();\n\n        stack.push(\n            new CallCode(gas, address, value, memoryStart, memoryLength, outputStart, outputLength)\n        );\n    },\n\n    RETURN: (state: State<Inst, Expr>): void => state.halt(memArgs(state, Return)),\n\n    DELEGATECALL: ({ stack }: State<Inst, Expr>): void => {\n        const gas = stack.pop();\n        const address = stack.pop();\n        const memoryStart = stack.pop();\n        const memoryLength = stack.pop();\n        const outputStart = stack.pop();\n        const outputLength = stack.pop();\n        stack.push(\n            new DelegateCall(gas, address, memoryStart, memoryLength, outputStart, outputLength)\n        );\n    },\n\n    CREATE2: ({ stack }: State<Inst, Expr>): void => {\n        const value = stack.pop();\n        const memoryStart = stack.pop();\n        const memoryLength = stack.pop();\n        stack.push(new Create2(memoryStart, memoryLength, value));\n    },\n\n    STATICCALL: ({ stack }: State<Inst, Expr>): void => {\n        const gas = stack.pop();\n        const address = stack.pop();\n        const memoryStart = stack.pop();\n        const memoryLength = stack.pop();\n        const outputStart = stack.pop();\n        const outputLength = stack.pop();\n        stack.push(\n            new StaticCall(gas, address, memoryStart, memoryLength, outputStart, outputLength)\n        );\n    },\n\n    REVERT: (state: State<Inst, Expr>): void => state.halt(memArgs(state, Revert)),\n\n    SELFDESTRUCT: (state: State<Inst, Expr>): void => {\n        const address = state.stack.pop();\n        state.halt(new SelfDestruct(address));\n    },\n};\n\nexport const PC = (opcode: Opcode, { stack }: State<Inst, Expr>) =>\n    stack.push(new Val(BigInt(opcode.offset)));\n\nexport const INVALID = (opcode: Opcode, state: State<Inst, Expr>): void => {\n    state.halt(new Invalid(`Invalid instruction (0x${opcode.opcode.toString(16)})`));\n};\n","const BZZR0 = '627a7a7230';\nconst BZZR1 = '627a7a7231';\nconst IPFS = '69706673';\n\nconst SOLC = '736f6c63';\n\nconst protocols: [RegExp, 'bzzr' | 'ipfs'][] = [\n    /**\n     * https://docs.soliditylang.org/en/v0.5.8/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n     */\n    [new RegExp(`a165${BZZR0}5820([a-f0-9]{64})0029$`), 'bzzr'],\n\n    /**\n     * https://docs.soliditylang.org/en/v0.5.9/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n     * https://blog.soliditylang.org/2019/05/28/solidity-0.5.9-release-announcement/\n     */\n    [new RegExp(`a265${BZZR1}5820([a-f0-9]{64})64${SOLC}43([a-f0-9]{6})0032$`), 'bzzr'],\n\n    /**\n     * v0.6.2 ends with `0x00 0x33` but v0.6.1 ends with `0x00 0x32`\n     * https://blog.soliditylang.org/2019/12/17/solidity-0.6.0-release-announcement/\n     * https://docs.soliditylang.org/en/v0.6.2/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n     */\n    [new RegExp(`a264${IPFS}5822([a-f0-9]{68})64${SOLC}43([a-f0-9]{6})0033$`), 'ipfs'],\n];\n\n/**\n * Represents the metadata hash protocols embedded in bytecode by `solc`.\n */\nexport class Metadata {\n    constructor(readonly protocol: 'bzzr' | 'ipfs', readonly hash: string, readonly solc: string) {}\n\n    get url(): string {\n        return `${this.protocol}://${this.hash}`;\n    }\n}\n\n/**\n * Splits the `bytecode` into executable code and embedded metadata hash as\n * placed by the Solidity compiler, if present in the `bytecode`.\n *\n * @param bytecode the contract `bytecode` to test for metadata hash from, hex encoded.\n * @returns An tuple where the first component is the executable code and\n * second one is the metadata hash when the metadata is present.\n * Otherwise, the original `bytecode` and `undefined` respectively.\n */\nexport function stripMetadataHash(bytecode: string): [string, Metadata | undefined] {\n    for (const [re, protocol] of protocols) {\n        const match = bytecode.match(re);\n        if (match && match[1]) {\n            return [\n                bytecode.substring(0, match.index),\n                new Metadata(protocol, match[1], match[2] ? convertVersion(match[2]) : '<0.5.9'),\n            ];\n        }\n    }\n\n    return [bytecode, undefined];\n\n    /**\n     *\n     * @param solcVersion\n     * @returns\n     */\n    function convertVersion(solcVersion: string) {\n        const slice = (pos: number) => parseInt(solcVersion.slice(pos, pos + 2), 16).toString();\n        return `${slice(0)}.${slice(2)}.${slice(4)}`;\n    }\n}\n","/**\n * Set of `PUSHn` opcodes.\n */\nconst PUSHES = {\n    PUSH1: 0x60,\n    PUSH2: 0x61,\n    PUSH3: 0x62,\n    PUSH4: 0x63,\n    PUSH5: 0x64,\n    PUSH6: 0x65,\n    PUSH7: 0x66,\n    PUSH8: 0x67,\n    PUSH9: 0x68,\n    PUSH10: 0x69,\n    PUSH11: 0x6a,\n    PUSH12: 0x6b,\n    PUSH13: 0x6c,\n    PUSH14: 0x6d,\n    PUSH15: 0x6e,\n    PUSH16: 0x6f,\n    PUSH17: 0x70,\n    PUSH18: 0x71,\n    PUSH19: 0x72,\n    PUSH20: 0x73,\n    PUSH21: 0x74,\n    PUSH22: 0x75,\n    PUSH23: 0x76,\n    PUSH24: 0x77,\n    PUSH25: 0x78,\n    PUSH26: 0x79,\n    PUSH27: 0x7a,\n    PUSH28: 0x7b,\n    PUSH29: 0x7c,\n    PUSH30: 0x7d,\n    PUSH31: 0x7e,\n    PUSH32: 0x7f,\n};\n\n/**\n * Set of opcodes defined by the EVM.\n *\n * They are constructed from two kinds of opcodes.\n * `Unary` opcodes which takes no-arguments and,\n * `PUSHn` opcodes which takes an `n` byte argument from the bytecode.\n *\n * From these two different categories is easier to distinguish between the two.\n */\nexport const OPCODES = {\n    STOP: 0x00,\n    ADD: 0x01,\n    MUL: 0x02,\n    SUB: 0x03,\n    DIV: 0x04,\n    SDIV: 0x05,\n    MOD: 0x06,\n    SMOD: 0x07,\n    ADDMOD: 0x08,\n    MULMOD: 0x09,\n    EXP: 0x0a,\n    SIGNEXTEND: 0x0b,\n    LT: 0x10,\n    GT: 0x11,\n    SLT: 0x12,\n    SGT: 0x13,\n    EQ: 0x14,\n    ISZERO: 0x15,\n    AND: 0x16,\n    OR: 0x17,\n    XOR: 0x18,\n    NOT: 0x19,\n    BYTE: 0x1a,\n    SHL: 0x1b,\n    SHR: 0x1c,\n    SAR: 0x1d,\n    SHA3: 0x20,\n    ADDRESS: 0x30,\n    BALANCE: 0x31,\n    ORIGIN: 0x32,\n    CALLER: 0x33,\n    CALLVALUE: 0x34,\n    CALLDATALOAD: 0x35,\n    CALLDATASIZE: 0x36,\n    CALLDATACOPY: 0x37,\n    CODESIZE: 0x38,\n    CODECOPY: 0x39,\n    GASPRICE: 0x3a,\n    EXTCODESIZE: 0x3b,\n    EXTCODECOPY: 0x3c,\n    RETURNDATASIZE: 0x3d,\n    RETURNDATACOPY: 0x3e,\n    EXTCODEHASH: 0x3f,\n    BLOCKHASH: 0x40,\n    COINBASE: 0x41,\n    TIMESTAMP: 0x42,\n    NUMBER: 0x43,\n    DIFFICULTY: 0x44,\n    GASLIMIT: 0x45,\n    CHAINID: 0x46, // https://www.evm.codes/#46\n    SELFBALANCE: 0x47, // https://www.evm.codes/#47\n    POP: 0x50,\n    MLOAD: 0x51,\n    MSTORE: 0x52,\n    MSTORE8: 0x53,\n    SLOAD: 0x54,\n    SSTORE: 0x55,\n    JUMP: 0x56,\n    JUMPI: 0x57,\n    PC: 0x58,\n    MSIZE: 0x59,\n    GAS: 0x5a,\n    JUMPDEST: 0x5b,\n    ...PUSHES,\n    DUP1: 0x80,\n    DUP2: 0x81,\n    DUP3: 0x82,\n    DUP4: 0x83,\n    DUP5: 0x84,\n    DUP6: 0x85,\n    DUP7: 0x86,\n    DUP8: 0x87,\n    DUP9: 0x88,\n    DUP10: 0x89,\n    DUP11: 0x8a,\n    DUP12: 0x8b,\n    DUP13: 0x8c,\n    DUP14: 0x8d,\n    DUP15: 0x8e,\n    DUP16: 0x8f,\n    SWAP1: 0x90,\n    SWAP2: 0x91,\n    SWAP3: 0x92,\n    SWAP4: 0x93,\n    SWAP5: 0x94,\n    SWAP6: 0x95,\n    SWAP7: 0x96,\n    SWAP8: 0x97,\n    SWAP9: 0x98,\n    SWAP10: 0x99,\n    SWAP11: 0x9a,\n    SWAP12: 0x9b,\n    SWAP13: 0x9c,\n    SWAP14: 0x9d,\n    SWAP15: 0x9e,\n    SWAP16: 0x9f,\n    LOG0: 0xa0,\n    LOG1: 0xa1,\n    LOG2: 0xa2,\n    LOG3: 0xa3,\n    LOG4: 0xa4,\n    CREATE: 0xf0,\n    CALL: 0xf1,\n    CALLCODE: 0xf2,\n    RETURN: 0xf3,\n    DELEGATECALL: 0xf4,\n    CREATE2: 0xf5,\n    STATICCALL: 0xfa,\n    REVERT: 0xfd,\n    INVALID: 0xfe,\n    SELFDESTRUCT: 0xff,\n} as const;\n\n/**\n * A map from numeric opcodes to string mnemonics.\n */\nexport const MNEMONICS = Object.fromEntries(\n    Object.entries(OPCODES).map(([key, value]) => [value, key as keyof typeof OPCODES])\n);\n\n/**\n * Represents all unary opcodes defined by the EVM.\n * Essentially, all but `PUSHn` opcodes are unary opcodes.\n */\nexport interface Unary {\n    /**\n     * Represents a valid opcode.\n     *\n     * In https://www.evm.codes/ you can find an overview of each EVM opcode.\n     *\n     * If the `opcode` given is not a valid opcode,\n     * you can provide `INVALID` as `mnemonic`.\n     */\n    mnemonic: Exclude<keyof typeof OPCODES, keyof typeof PUSHES>;\n\n    /**\n     * A `Unary` opcode does not include any `pushData`.\n     */\n    pushData: null;\n}\n\n/**\n * Represents a `PUSHn` mnemonic augmented with its `pushData`.\n */\nexport interface Push {\n    /**\n     * A `PUSHn` opcode only permits a `PUSHn` opcode.\n     */\n    mnemonic: keyof typeof PUSHES;\n\n    /**\n     * If this `Opcode` is a `PUSHn` instruction,\n     * then `pushData` contains the data attached to this instruction.\n     * Otherwise, `null`.\n     */\n    pushData: Uint8Array;\n}\n\n/**\n *\n */\nexport type Opcode = {\n    /**\n     * This is the offset in the bytecode where this `Opcode` was found.\n     * Both jump instructions, _i.e._, `JUMP` and `JUMPI`,\n     * expects a stack operand referencing this `offset` in the bytecode.\n     */\n    readonly offset: number;\n\n    /**\n     * The Program Counter of this `Opcode`.\n     * The index in the `Opcode[]` where this `Opcode` is inserted.\n     */\n    readonly pc: number;\n\n    /**\n     * Any byte number, _i.e._, between 0 and 255 representing the opcode byte.\n     * The `opcode` may not be a valid opcode.\n     */\n    readonly opcode: number;\n} & (Unary | Push);\n\n/**\n * Represents the `Opcode`s found in `code`.\n *\n * @param code the buffer containing the bytecode to decode\n * @returns\n */\nexport function decode(code: Uint8Array): {\n    /**\n     * Represents the `Opcode`s found in `code`.\n     */\n    opcodes: Opcode[];\n    /**\n     * Map between `JUMPDEST` instructions offset, _i.e._,\n     * as they appear in the `code` buffer and its index in the `opcodes` array.\n     *\n     * It allows to quickly find the `JUMPDEST` instruction.\n     */\n    jumpdests: { [jd: number]: number };\n} {\n    const opcodes = [];\n    const jumpdests: { [jd: number]: number } = {};\n\n    for (let i = 0; i < code.length; i++) {\n        const opcode = code[i];\n        const mnemonic = MNEMONICS[opcode] ?? 'INVALID';\n        if (mnemonic === 'JUMPDEST') {\n            jumpdests[i] = opcodes.length;\n        }\n        opcodes.push({\n            offset: i,\n            pc: opcodes.length,\n            opcode,\n            ...(isPush(mnemonic)\n                ? {\n                      mnemonic,\n                      pushData: (() => {\n                          const pushSize = opcode - OPCODES.PUSH1 + 0x01;\n                          const data = code.subarray(i + 1, i + pushSize + 1);\n                          i += pushSize;\n                          return data;\n                      })(),\n                  }\n                : {\n                      mnemonic,\n                      pushData: null,\n                  }),\n        });\n    }\n\n    return { opcodes, jumpdests };\n\n    /**\n     * Asserts whether `mnemonic` is a `PUSHn` opcode.\n     *\n     * @param mnemonic the `mnemonic` to check.\n     * @returns `true` when `mnemonic` is a `PUSHn` opcode.\n     * `false` otherwise.\n     */\n    function isPush(mnemonic: keyof typeof OPCODES): mnemonic is keyof typeof PUSHES {\n        return mnemonic in PUSHES;\n    }\n}\n\nexport function formatOpcode(op: Opcode): string {\n    const offset = op.offset.toString().padStart(4, ' ').toUpperCase();\n    const pc = op.pc.toString().padStart(4, ' ').toUpperCase();\n    const pushData = op.pushData\n        ? ` 0x${toHex(op.pushData)} (${parseInt(toHex(op.pushData), 16)})`\n        : '';\n\n    return `${pc}:${offset}    ${op.mnemonic}${pushData}`;\n}\n\n/**\n *\n * @param buffer\n * @returns\n */\nexport function toHex(buffer: Uint8Array): string {\n    return buffer.reduce((str, elem) => str + elem.toString(16).padStart(2, '0'), '');\n}\n","/**\n *\n */\nexport class Stack<in out T> {\n    readonly values: T[] = [];\n\n    /**\n     *\n     * @param elem\n     */\n    push(elem: T): void | never {\n        if (this.values.length >= 1024) {\n            throw new Stack.Error('Stack too deep');\n        }\n\n        this.values.unshift(elem);\n    }\n\n    pop(): T | never {\n        if (this.values.length === 0) {\n            throw new Stack.Error('POP with empty stack');\n        }\n\n        // The non-null assertion operator `!` is needed here because the\n        // guard `length === 0` does not track array's emptiness.\n        // See https://github.com/microsoft/TypeScript/issues/30406.\n        return this.values.shift()!;\n    }\n\n    dup(position: number): void | never {\n        if (position < 0 || position > 15) {\n            throw new Stack.Error('Unsupported position for duplication operation');\n        } else if (!(position in this.values)) {\n            throw new Stack.Error('Invalid duplication operation, position was not found');\n        }\n\n        this.push(this.values[position]);\n    }\n\n    swap(secondPosition: number): void | never {\n        if (secondPosition < 1 || secondPosition > 16) {\n            throw new Stack.Error('Unsupported position for swap operation');\n        } else if (!(secondPosition in this.values)) {\n            throw new Stack.Error('Invalid swap operation, position was not found');\n        }\n\n        const firstValue = this.values[0];\n        const secondValue = this.values[secondPosition];\n        this.values[0] = secondValue;\n        this.values[secondPosition] = firstValue;\n    }\n\n    clone(): Stack<T> {\n        const stack = new Stack<T>();\n        stack.values.push(...this.values);\n        return stack;\n    }\n\n    static Error = class extends Error {\n        constructor(message: string) {\n            super(message);\n        }\n        override name = 'Stack.Error';\n    };\n}\n\n/**\n * Represents the state of an EVM run with statements `S` and expressions `E`.\n */\nexport class State<S, E> {\n    /**\n     * Indicates whether this `State` has been halted.\n     */\n    private _halted = false;\n\n    /**\n     * The statements executed that lead to this `State`.\n     */\n    readonly stmts: S[] = [];\n\n    /**\n     *\n     * @param stack\n     * @param memory\n     */\n    constructor(readonly stack = new Stack<E>(), readonly memory: { [location: number]: E } = {}) {}\n\n    /**\n     * Indicates whether this `State` has been halted.\n     *\n     * When `true`, no more execution should be allowed against this `State`.\n     */\n    get halted(): boolean {\n        return this._halted;\n    }\n\n    /**\n     * The last statement in this `State`.\n     */\n    get last(): S | undefined {\n        return this.stmts.at(-1);\n    }\n\n    /**\n     * Halts this `State`.\n     * It adds `last` to `stmts` and sets `halted` to `true`.\n     *\n     * @param last The `S` that halts this `State`.\n     */\n    halt(last: S): void {\n        this.stmts.push(last);\n        this._halted = true;\n    }\n\n    /**\n     * Creates a detached clone from this `State`.\n     * The cloned state only shallow copies both `stack` and `memory`,\n     * while `stmts` will be empty and `halted` false.\n     *\n     * Note however the shallow copy means the structure of both `stack` and `memory` are cloned,\n     * not their contents.\n     * This means that any expression `E` in either the `stack` or `memory`\n     * will be shared across instances if they are references.\n     *\n     * @returns a new `State` detached from this one.\n     */\n    clone(): State<S, E> {\n        return new State(this.stack.clone(), { ...this.memory });\n    }\n}\n\n/**\n * Represents the volatile memory of `State`, _i.e._, its `stack` and `memory`.\n */\nexport type Ram<E> = Pick<State<never, E>, 'stack' | 'memory'>;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import type { Expr, Inst } from './evm/expr';\nimport { Not } from './evm/logic';\nimport type { Revert } from './evm/system';\nimport { State } from './state';\nimport { EVM } from './evm';\nimport { stringifyEvents } from './evm/log';\nimport { stringifyMappings, stringifyStructs, stringifyVariables } from './evm/storage';\nimport { OPCODES } from './opcode';\n\n/**\n *\n */\nexport class Contract {\n    /**\n     *\n     */\n    readonly evm: EVM;\n\n    /**\n     *\n     */\n    readonly main: Stmt[];\n\n    /**\n     *\n     */\n    readonly functions: { [selector: string]: PublicFunction } = {};\n\n    constructor(bytecode: string) {\n        this.evm = EVM.from(bytecode);\n        const main = new State<Inst, Expr>();\n        this.evm.run(0, main);\n        this.main = build(main);\n        for (const [selector, branch] of this.evm.functionBranches) {\n            this.evm.run(branch.pc, branch.state);\n            this.functions[selector] = new PublicFunction(build(branch.state), selector);\n        }\n    }\n\n    get metadata(): EVM['metadata'] {\n        return this.evm.metadata;\n    }\n\n    /**\n     *\n     * @returns\n     */\n    getFunctions(): string[] {\n        return Object.values(this.functions).flatMap(fn =>\n            fn.label === undefined ? [] : [fn.label]\n        );\n    }\n\n    // getEvents(): string[] {\n    //     return [\n    //         ...new Set(\n    //             this.opcodes\n    //                 .filter(\n    //                     (opcode): opcode is Opcode & { mnemonic: 'PUSH32' } =>\n    //                         opcode.opcode === OPCODES.PUSH32\n    //                 )\n    //                 .map(opcode => toHex(opcode.pushData))\n    //                 .filter(hash => hash in this.eventHashes)\n    //                 .map(hash => this.eventHashes[hash])\n    //         ),\n    //     ];\n    // }\n\n    // getABI() {\n    //     return Object.values(this.contract).map(fn => {\n    //         return {\n    //             type: 'function',\n    //             name: fn.label.split('(')[0],\n    //             payable: fn.payable,\n    //             constant: fn.constant,\n    //         };\n    //     });\n    // }\n\n    /**\n     * https://eips.ethereum.org/EIPS/eip-165\n     *\n     * @returns\n     */\n    isERC165(): boolean {\n        /**\n         * `bytes4(keccak256('supportsInterface(bytes4)'))`\n         */\n        const selector = '01ffc9a7';\n        return this.evm.functionBranches.has(selector);\n    }\n\n    /**\n     *\n     * @returns\n     */\n    decompile(): string {\n        let text = '';\n\n        text += stringifyEvents(this.evm.events);\n        text += stringifyStructs(this.evm.mappings);\n        text += stringifyMappings(this.evm.mappings);\n        text += stringifyVariables(this.evm.variables);\n        text += stringify(this.main);\n        for (const [, fn] of Object.entries(this.functions)) {\n            text += stringifyFunction(fn);\n        }\n\n        return text;\n    }\n\n    /**\n     * Migrated from old codebase.\n     * Evaluate if it makes sense to keep it.\n     *\n     * @param opcode\n     * @returns\n     */\n    containsOpcode(opcode: number | string): boolean {\n        const HALTS = [\n            OPCODES.STOP,\n            OPCODES.RETURN,\n            OPCODES.REVERT,\n            OPCODES.INVALID,\n            OPCODES.SELFDESTRUCT,\n        ] as number[];\n        let halted = false;\n        if (typeof opcode === 'string' && opcode in OPCODES) {\n            opcode = OPCODES[opcode as keyof typeof OPCODES];\n        } else if (typeof opcode === 'string') {\n            throw new Error('Invalid opcode provided');\n        }\n        for (let index = 0; index < this.evm.opcodes.length; index++) {\n            const currentOpcode = this.evm.opcodes[index].opcode;\n            if (currentOpcode === opcode && !halted) {\n                return true;\n            } else if (currentOpcode === OPCODES.JUMPDEST) {\n                halted = false;\n            } else if (HALTS.includes(currentOpcode)) {\n                halted = true;\n            }\n        }\n        return false;\n\n        // function fromHex(str: string): Uint8Array {\n        //     const buffer = new Uint8Array(str.length / 2);\n        //     for (let i = 0; i < buffer.length; i++) {\n        //         buffer[i] = parseInt(str.substr(i * 2, 2), 16);\n        //     }\n        //     return buffer;\n        // }\n    }\n}\n\nexport class If {\n    readonly name = 'If';\n    constructor(\n        readonly condition: Expr,\n        readonly trueBlock?: Stmt[],\n        readonly falseBlock?: Stmt[]\n    ) {}\n\n    toString() {\n        return `(${this.condition})`;\n    }\n}\n\nexport class CallSite {\n    readonly name = 'CallSite';\n\n    constructor(readonly selector: string) {}\n\n    toString() {\n        return `$${this.selector}();`;\n    }\n}\n\nexport function isRevertBlock(falseBlock: Stmt[]): falseBlock is [Revert] {\n    return (\n        falseBlock.length === 1 && 'name' in falseBlock[0] && falseBlock[0].name === 'Revert' //&&\n        // falseBlock[0].items !== undefined &&\n        // falseBlock[0].items.length === 0\n        // || falseCloneTree[0].name === 'INVALID'\n    );\n}\n\nexport class Require {\n    readonly name = 'Require';\n\n    constructor(readonly condition: Expr, readonly args: Expr[]) {}\n\n    toString() {\n        return `require(${this.condition}, ${this.args.join(', ')});`;\n    }\n}\n\nexport class PublicFunction {\n    /**\n     *\n     */\n    label: string | undefined = undefined;\n    readonly payable: boolean;\n    readonly visibility: string;\n    readonly constant: boolean;\n    readonly returns: [] = [];\n\n    constructor(readonly stmts: Stmt[], readonly selector: string) // readonly gasUsed: number,\n    // functionHashes: { [s: string]: string }\n    {\n        this.payable = true;\n        this.visibility = 'public';\n        this.constant = false;\n        this.returns = [];\n        // this.label = this.hash in functionHashes ? functionHashes[this.hash] : this.hash + '()';\n        if (\n            this.stmts.length > 0 &&\n            this.stmts[0] instanceof Require &&\n            this.stmts[0].condition.tag === 'IsZero' &&\n            this.stmts[0].condition.value.tag === 'CallValue'\n        ) {\n            this.payable = false;\n            this.stmts.shift();\n        }\n        if (this.stmts.length === 1 && this.stmts[0].name === 'Return') {\n            this.constant = true;\n        }\n        // if (this.selector in functionHashes) {\n        // const functionName = functionHashes[this.selector].split('(')[0];\n        // const argumentTypes = functionHashes[this.selector] .replace(functionName, '') .substr(1) .slice(0, -1) .split(',');\n        // if ( argumentTypes.length > 1 || (argumentTypes.length === 1 && argumentTypes[0] !== '')) {\n        // this.stmts.forEach(stmt =>\n        // updateCallDataLoad(stmt as unknown as Record<string, Expr>, argumentTypes)\n        // );\n        // }\n        // }\n    }\n}\n\n// export class Assign {\n//     readonly name = 'Asign';\n//     constructor(readonly i: number, readonly phi: Phi) {}\n//     eval() {\n//         return this;\n//     }\n//     toString() {\n//         return `local${this.i} = ${this.phi.toString()};`;\n//     }\n// }\n\nexport type Stmt = Inst | If | CallSite | Require;\n\nexport function build(state: State<Inst, Expr>): Stmt[] {\n    const visited = new WeakSet();\n    return buildState(state);\n\n    function buildState(state: State<Inst, Expr>): Stmt[] {\n        if (visited.has(state)) {\n            return [];\n        }\n\n        visited.add(state);\n\n        const last = state.last!;\n        if (last === undefined) return [];\n\n        for (let i = 0; i < state.stmts.length; i++) {\n            state.stmts[i] = state.stmts[i].eval();\n        }\n\n        switch (last.name) {\n            case 'Jumpi': {\n                if (last.evalCond.isVal()) {\n                    if (last.evalCond.val === 0n) {\n                        return [...state.stmts.slice(0, -1), ...buildState(last.fallBranch.state)];\n                    } else {\n                        return [...state.stmts.slice(0, -1), ...buildState(last.destBranch.state)];\n                    }\n                }\n\n                const trueBlock = buildState(last.destBranch.state);\n                const falseBlock = buildState(last.fallBranch.state);\n                return [\n                    ...state.stmts.slice(0, -1),\n                    ...(isRevertBlock(falseBlock)\n                        ? [\n                              new Require(\n                                  last.cond.eval(),\n                                  falseBlock[0].args.map(e => e.eval())\n                              ),\n                              ...trueBlock,\n                          ]\n                        : [new If(new Not(last.cond), falseBlock), ...trueBlock]),\n                ];\n            }\n            case 'SigCase': {\n                const falseBlock = buildState(last.fallBranch.state);\n                return [\n                    ...state.stmts.slice(0, -1),\n                    new If(last.condition, [new CallSite(last.condition.selector)], falseBlock),\n                ];\n            }\n            case 'Jump':\n                return [...state.stmts.slice(0, -1), ...buildState(last.destBranch.state)];\n            case 'JumpDest':\n                return [...state.stmts.slice(0, -1), ...buildState(last.fallBranch.state)];\n            default:\n                return state.stmts;\n        }\n    }\n}\n\n/**\n *\n * @param stmts\n * @param indentation\n * @returns\n */\nexport function stringify(stmts: Stmt[], indentation = 0): string {\n    let text = '';\n    for (const stmt of stmts) {\n        if (stmt instanceof If) {\n            const condition = stmt.toString();\n            text += ' '.repeat(indentation) + 'if ' + condition + ' {\\n';\n            text += stringify(stmt.trueBlock!, indentation + 4);\n            if (stmt.falseBlock) {\n                text += ' '.repeat(indentation) + '} else {\\n';\n                text += stringify(stmt.falseBlock, indentation + 4);\n            }\n            text += ' '.repeat(indentation) + '}\\n';\n            // }\n        } else {\n            text += ' '.repeat(indentation) + stmt.toString() + '\\n';\n        }\n    }\n\n    return text;\n}\n\n/**\n *\n * @param functionName\n * @param fn\n * @param functionHashes\n * @returns\n */\nfunction stringifyFunction(fn: PublicFunction): string {\n    let output = '';\n    output += 'function ';\n    if (fn.label !== undefined) {\n        const fullFunction = fn.label;\n        const fullFunctionName = fullFunction.split('(')[0];\n        const fullFunctionArguments = fullFunction\n            .replace(fullFunctionName, '')\n            .substring(1)\n            .slice(0, -1);\n        if (fullFunctionArguments) {\n            output += fullFunctionName + '(';\n            output += fullFunctionArguments\n                .split(',')\n                .map((a: string, i: number) => `${a} _arg${i}`)\n                .join(', ');\n            output += ')';\n        } else {\n            output += fullFunction;\n        }\n    } else {\n        output += fn.selector + '()';\n    }\n    output += ' ' + fn.visibility;\n    if (fn.constant) {\n        output += ' view';\n    }\n    if (fn.payable) {\n        output += ' payable';\n    }\n    if (fn.returns.length > 0) {\n        output += ` returns (${fn.returns.join(', ')})`;\n    }\n    output += ' {\\n';\n    output += stringify(fn.stmts, 4);\n    output += '}\\n\\n';\n    return output;\n}\n"],"names":["root","factory","exports","module","define","amd","a","i","self","CallValue","Tag","eval","this","str","CallDataLoad","constructor","location","super","isVal","val","_str","prec","CallDataSize","ENV","CALLVALUE","stack","push","CALLDATALOAD","pop","CALLDATASIZE","tag","Val","isZero","isJumpDest","jumpDest","text","toString","op","Bin","left","right","isPush","Branch","pc","state","key","Jump","offset","destBranch","name","next","Jumpi","cond","fallBranch","evalCond","SigCase","condition","makeBranch","clone","opcodes","jumpdests","functionBranches","JUMP","_opcode","getDest","halt","JUMPI","opcode","destpc","last","set","selector","offset2","Error","Number","undefined","dest","find","o","formatOpcode","make","table","adapter","Object","fromEntries","entries","map","mnemonic","fn","makeStack","makeState","TABLE","MATH","LOGIC","SYM","MEMORY","JUMPDEST","_state","PUSHES","pushData","STACK","SYSTEM","PC","INVALID","EVM","metadata","insts","chunks","Map","errors","events","variables","mappings","FLOW","STORAGE","LOGS","Array","keys","k","MNEMONICS","static","bytecode","code","stripMetadataHash","decode","Buffer","from","replace","start","run","branch","pc0","branches","length","shift","chunk","get","states","exec","b","unshift","halted","oplen","OPCODES","JumpDest","err","message","inv","Invalid","values","slice","join","pcend","cmp","lhs","rhs","cmpval","s","topic","event","sig","eventName","split","params","substring","param","indexedCount","Log","topics","args","mem","e","size","log","topicsCount","memory","stmts","eventTopic","padStart","MLoad","BigInt","LOG0","LOG1","LOG2","LOG3","LOG4","Cmp","equal","Shift","Byte","value","Lt","Gt","Eq","IsZero","And","test","Or","Xor","Not","Unary","pos","data","Shl","Shr","Sar","Sig","fromSHRsig","cc","fromDIVEXPsig","Cons","LT","bin","GT","SLT","SGT","EQ","eqHook","ISZERO","AND","OR","XOR","NOT","BYTE","position","SHL","SHR","SAR","Add","Mul","Sub","Div","Mod","Exp","ADD","MUL","SUB","DIV","SDIV","MOD","SMOD","ADDMOD","mod","MULMOD","EXP","SIGNEXTEND","loc","MStore","mstore","MLOAD","MSTORE","MSTORE8","toHex","PUSH1","PUSH2","PUSH3","PUSH4","PUSH5","PUSH6","PUSH7","PUSH8","PUSH9","PUSH10","PUSH11","PUSH12","PUSH13","PUSH14","PUSH15","PUSH16","PUSH17","PUSH18","PUSH19","PUSH20","PUSH21","PUSH22","PUSH23","PUSH24","PUSH25","PUSH26","PUSH27","PUSH28","PUSH29","PUSH30","PUSH31","PUSH32","POP","DUP1","dup","DUP2","DUP3","DUP4","DUP5","DUP6","DUP7","DUP8","DUP9","DUP10","DUP11","DUP12","DUP13","DUP14","DUP15","DUP16","SWAP1","swap","SWAP2","SWAP3","SWAP4","SWAP5","SWAP6","SWAP7","SWAP8","SWAP9","SWAP10","SWAP11","SWAP12","SWAP13","SWAP14","SWAP15","SWAP16","Variable","label","types","output","forEach","hash","variable","index","expr","filter","t","trim","Set","structs","mapping","struct","stringifyMapping","mappingKey","mappingValue","deepMapping","mappingChild","mappingChild0","type","includes","items","mappingChild2","MappingStore","structlocation","mappingName","item","SStore","variableName","indexOf","MappingLoad","maybeName","SLoad","parseSha3","sha","shas","base","arg","SLOAD","parts","SSTORE","sstoreVariable","INFO","ADDRESS","ORIGIN","CALLER","CODESIZE","GASPRICE","RETURNDATASIZE","COINBASE","TIMESTAMP","NUMBER","DIFFICULTY","GASLIMIT","CHAINID","SELFBALANCE","MSIZE","GAS","Symbol0","symbol","type2","Symbol1","DataCopy","symbol0","symbol1","datacopy","BALANCE","address","CALLDATACOPY","CODECOPY","EXTCODESIZE","EXTCODECOPY","RETURNDATACOPY","EXTCODEHASH","BLOCKHASH","blockNumber","Sha3","memoryStart","memoryLength","Create","Call","gas","outputStart","outputLength","throwOnFail","ReturnData","retOffset","retSize","wrapped","CallCode","Create2","StaticCall","DelegateCall","Stop","Return","every","hexstr","String","fromCharCode","parseInt","hex2a","Revert","reason","SelfDestruct","memArgs","Klass","MAXSIZE","SHA3","STOP","CREATE","CALL","CALLCODE","RETURN","DELEGATECALL","CREATE2","STATICCALL","REVERT","SELFDESTRUCT","SOLC","protocols","RegExp","Metadata","protocol","solc","url","re","match","convertVersion","solcVersion","buffer","reduce","elem","pushSize","subarray","toUpperCase","Stack","secondPosition","firstValue","secondValue","State","_halted","at","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","functions","evm","main","build","PublicFunction","getFunctions","flatMap","isERC165","has","decompile","stringifyEvents","stringifyStructs","stringifyMappings","stringifyVariables","stringify","stringifyFunction","containsOpcode","HALTS","currentOpcode","If","trueBlock","falseBlock","CallSite","isRevertBlock","Require","returns","payable","visibility","constant","visited","WeakSet","buildState","add","indentation","stmt","repeat","fullFunction","fullFunctionName","fullFunctionArguments"],"sourceRoot":""}