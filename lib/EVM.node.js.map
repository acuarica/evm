{"version":3,"file":"EVM.node.js","mappings":"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","sources":["webpack://evm/./src/evm/env.ts","webpack://evm/./src/evm/expr.ts","webpack://evm/./src/evm/flow.ts","webpack://evm/./src/evm/index.ts","webpack://evm/./src/evm/log.ts","webpack://evm/./src/evm/logic.ts","webpack://evm/./src/evm/math.ts","webpack://evm/./src/evm/memory.ts","webpack://evm/./src/evm/stack.ts","webpack://evm/./src/evm/storage.ts","webpack://evm/./src/evm/sym.ts","webpack://evm/./src/evm/system.ts","webpack://evm/./src/metadata.ts","webpack://evm/./src/opcode.ts","webpack://evm/./src/state.ts","webpack://evm/webpack/bootstrap","webpack://evm/./src/index.ts"],"sourcesContent":["import type { Stack } from '../state';\nimport { type Expr, Tag } from './expr';\n\nexport class CallValue extends Tag('CallValue') {\n    eval(): Expr {\n        return this;\n    }\n    str(): string {\n        return 'msg.value';\n    }\n}\n\nexport class CallDataLoad extends Tag('CallDataLoad') {\n    constructor(public location: Expr) {\n        super();\n    }\n    eval(): Expr {\n        this.location = this.location.eval();\n        return this;\n    }\n    str(): string {\n        return this.location.isVal() && this.location.val === 0n\n            ? 'msg.data'\n            : this.location.isVal() && (this.location.val - 4n) % 32n === 0n\n            ? `_arg${(this.location.val - 4n) / 32n}`\n            : `msg.data[${this.location._str(CallDataLoad.prec)}]`;\n    }\n}\n\nexport class CallDataSize extends Tag('CallDataSize') {\n    eval(): Expr {\n        return this;\n    }\n    str(): string {\n        return 'msg.data.length';\n    }\n}\n\nexport const ENV = {\n    /**\n     * Get deposited value by the instruction/transaction responsible for this execution.\n     *\n     * @param stack\n     */\n    CALLVALUE: (stack: Stack<Expr>): void => stack.push(new CallValue()),\n    CALLDATALOAD: (stack: Stack<Expr>): void => {\n        const location = stack.pop();\n        stack.push(new CallDataLoad(location));\n    },\n    CALLDATASIZE: (stack: Stack<Expr>): void => stack.push(new CallDataSize()),\n};\n","import type { Add, Div, Exp, Mod, Mul, Sub } from './math';\nimport type { And, Byte, Eq, Gt, IsZero, Lt, Not, Or, Sar, Shl, Shr, Sig, Xor } from './logic';\nimport type { CallDataLoad, CallDataSize, CallValue } from './env';\nimport type { DataCopy, Symbol0, Symbol1 } from './sym';\nimport type { MLoad, MStore } from './memory';\nimport type {\n    Call,\n    CallCode,\n    Create,\n    Create2,\n    DelegateCall,\n    Invalid,\n    Return,\n    ReturnData,\n    Revert,\n    SelfDestruct,\n    Sha3,\n    StaticCall,\n    Stop,\n} from './system';\nimport type { Log } from './log';\nimport type { Branch, Jump, JumpDest, Jumpi, SigCase } from './flow';\nimport type { MappingLoad, MappingStore, SLoad, SStore } from './storage';\n\n/**\n *\n */\nexport type Expr =\n    | Val\n    | Add\n    | Mul\n    | Sub\n    | Div\n    | Mod\n    | Exp\n    | Lt\n    | Gt\n    | Eq\n    | IsZero\n    | And\n    | Or\n    | Xor\n    | Not\n    | Byte\n    | Shl\n    | Shr\n    | Sar\n    | Sig\n    | CallValue\n    | CallDataLoad\n    | CallDataSize\n    | Symbol0\n    | Symbol1\n    | DataCopy\n    | MLoad\n    | Sha3\n    | Create\n    | Call\n    | ReturnData\n    | CallCode\n    | Create2\n    | StaticCall\n    | DelegateCall\n    | SLoad\n    | MappingLoad;\n\n/**\n * Base definition for any type that is `Stmt`.\n */\nexport interface IInst {\n    /**\n     * The `name` tag of this `IStmt`.\n     */\n    readonly name: string;\n\n    eval(): Inst;\n\n    next?(): Branch[];\n}\n\n/**\n *\n */\nexport type Inst =\n    | MStore\n    | Stop\n    | Return\n    | Revert\n    | SelfDestruct\n    | Invalid\n    | Log\n    | Jump\n    | Jumpi\n    | JumpDest\n    | SigCase\n    | SStore\n    | MappingStore;\n\nexport function Tag<N extends string>(tag: N, prec: number = Val.prec) {\n    abstract class Tag {\n        readonly tag: N = tag;\n\n        static readonly prec = prec;\n\n        readonly type?: string;\n\n        isVal(): this is Val {\n            return this.tag === 'Val';\n        }\n\n        isZero(): this is Val {\n            return this.isVal() && this.val === 0n;\n        }\n\n        isJumpDest() {\n            return this.isVal() && this.jumpDest !== null;\n        }\n\n        /**\n         * hghghg\n         */\n        abstract eval(): Expr;\n\n        /**\n         *\n         */\n        abstract str(): string;\n\n        _str(prec: any): string {\n            const text = this.str();\n            return Tag.prec < prec ? `(${text})` : text;\n        }\n\n        toString() {\n            return this.str();\n        }\n    }\n\n    return Tag;\n}\n\nexport function Bin<N extends string>(tag: N, op: string, prec: number) {\n    abstract class Bin extends Tag(tag, prec) {\n        constructor(readonly left: Expr, readonly right: Expr) {\n            super();\n        }\n\n        str() {\n            return `${this.left._str(prec)} ${op} ${this.right._str(prec)}`;\n        }\n    }\n\n    return Bin;\n}\n\nexport class Val extends Tag('Val', 16) {\n    jumpDest: number | null = null;\n\n    constructor(readonly val: bigint, readonly isPush = false) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return `${this.isJumpDest() ? '[J]' : ''}0x${this.val.toString(16)}`;\n    }\n}\n","import type { Inst, Expr, IInst, Val } from './expr';\nimport type { State } from '../state';\nimport type { Sig } from './logic';\nimport { type decode, formatOpcode, type Opcode } from '../opcode';\n\nexport class Branch {\n    constructor(readonly pc: number, readonly state: State<Inst, Expr>) {}\n\n    get key() {\n        return this.pc;\n    }\n}\n\nexport class Jump implements IInst {\n    readonly name = 'Jump';\n\n    constructor(readonly offset: Expr, readonly destBranch: Branch) {}\n\n    eval() {\n        return this;\n    }\n    toString() {\n        return `goto :${this.offset} branch:${this.destBranch.key}`;\n    }\n    next() {\n        return [this.destBranch];\n    }\n}\n\nexport class Jumpi implements IInst {\n    readonly name = 'Jumpi';\n\n    readonly evalCond: Expr;\n\n    constructor(\n        readonly cond: Expr,\n        readonly offset: Expr,\n        readonly fallBranch: Branch,\n        readonly destBranch: Branch\n    ) {\n        this.evalCond = cond.eval();\n    }\n\n    eval() {\n        return this;\n    }\n    toString() {\n        return `when ${this.cond} goto ${this.destBranch.key} or fall ${this.fallBranch.key}`;\n    }\n\n    next() {\n        return this.evalCond.isVal()\n            ? this.evalCond.val === 0n\n                ? [this.fallBranch]\n                : [this.destBranch]\n            : [this.destBranch, this.fallBranch];\n    }\n}\n\nexport class JumpDest implements IInst {\n    readonly name = 'JumpDest';\n    constructor(readonly fallBranch: Branch) {}\n    eval() {\n        return this;\n    }\n    toString() {\n        return `fall: ${this.fallBranch.key}:`;\n    }\n\n    next() {\n        return [this.fallBranch];\n    }\n}\n\nexport class SigCase implements IInst {\n    readonly name = 'SigCase';\n    constructor(readonly condition: Sig, readonly offset: Expr, readonly fallBranch: Branch) {}\n    eval() {\n        return this;\n    }\n    toString() {\n        return `case when ${this.condition} goto ${this.offset} or fall ${this.fallBranch.key}`;\n    }\n\n    next(): Branch[] {\n        return [this.fallBranch];\n    }\n}\n\nexport function makeBranch(pc: number, state: State<Inst, Expr>) {\n    return new Branch(pc, state.clone());\n}\n\nexport interface ISelectorBranches {\n    /**\n     * store selectors starting point.\n     */\n    readonly functionBranches: Map<string, { pc: number; state: State<Inst, Expr> }>;\n}\n\nexport function FLOW(\n    { opcodes, jumpdests }: ReturnType<typeof decode>,\n    { functionBranches }: ISelectorBranches\n) {\n    return {\n        JUMP: (_opcode: Opcode, state: State<Inst, Expr>): void => {\n            const offset = state.stack.pop();\n            const destpc = getDest(offset);\n            const destBranch = makeBranch(destpc, state);\n            state.halt(new Jump(offset, destBranch));\n        },\n\n        JUMPI: (opcode: Opcode, state: State<Inst, Expr>): void => {\n            const offset = state.stack.pop();\n            const cond = state.stack.pop();\n            const destpc = getDest(offset);\n\n            const fallBranch = makeBranch(opcode.pc + 1, state);\n\n            let last: SigCase | Jumpi;\n            if (cond.tag === 'Sig') {\n                functionBranches.set(cond.selector, {\n                    pc: destpc,\n                    state: state.clone(),\n                });\n                last = new SigCase(cond, offset, fallBranch);\n            } else {\n                last = new Jumpi(cond, offset, fallBranch, makeBranch(destpc, state));\n            }\n            state.halt(last);\n        },\n    };\n\n    /**\n     *\n     * @param offset\n     * @returns\n     */\n    function getDest(offset: Expr): number {\n        const offset2 = offset.eval();\n        if (!offset2.isVal()) {\n            throw new Error(`Expected numeric offset, found ${offset}`);\n        }\n        const destpc = jumpdests[Number(offset2.val)];\n        if (destpc !== undefined) {\n            (offset as Val).jumpDest = destpc;\n            return destpc;\n        } else {\n            const dest = opcodes.find(o => o.offset === Number(offset2.val));\n            if (!dest) {\n                throw new Error('Expected `JUMPDEST` in JUMP destination, but none was found');\n            }\n            throw new Error('JUMP destination should be JUMPDEST but found' + formatOpcode(dest));\n        }\n    }\n}\n","import { decode, OPCODES, type Opcode, MNEMONICS } from '../opcode';\nimport { type Stack, State as TState } from '../state';\nimport { type Metadata, stripMetadataHash } from '../metadata';\n\nimport type { Expr, IInst, Inst } from './expr';\n\nimport { PUSHES, STACK } from './stack';\nimport { MATH } from './math';\nimport { LOGIC } from './logic';\nimport { ENV } from './env';\nimport { SYM as SYMBOLS } from './sym';\nimport { MEMORY } from './memory';\nimport { Invalid, INVALID, PC, SYSTEM } from './system';\nimport { LOGS, type IEvents } from './log';\nimport { type IStore, STORAGE } from './storage';\nimport { Branch, FLOW, type ISelectorBranches, JumpDest, makeBranch } from './flow';\n\ntype State = TState<Inst, Expr>;\n\nfunction make<F, T extends { [mnemonic: string]: F }>(\n    table: T,\n    adapter: (fn: F) => (opcode: Opcode, state: State) => void\n) {\n    return Object.fromEntries(\n        Object.entries(table).map(([mnemonic, fn]) => [mnemonic, adapter(fn)])\n    ) as { [mnemonic in keyof T]: (opcode: Opcode, state: State) => void };\n}\n\nfunction makeStack<T extends { [mnemonic: string]: (stack: Stack<Expr>) => void }>(table: T) {\n    return make(table, (fn: (stack: Stack<Expr>) => void) => (_opcode, state) => fn(state.stack));\n}\n\nfunction makeState<T extends { [mnemonic: string]: (state: State) => void }>(table: T) {\n    return make(table, (fn: (state: State) => void) => (_opcode, state) => fn(state));\n}\n\nconst TABLE = {\n    ...makeStack(MATH),\n    ...makeStack(LOGIC),\n    ...makeStack(ENV),\n    ...makeState(SYMBOLS),\n    ...makeState(MEMORY),\n    JUMPDEST: (_opcode: Opcode, _state: State) => {},\n    ...make(\n        PUSHES,\n        (fn: (pushData: Uint8Array, stack: Stack<Expr>) => void) => (opcode, state) =>\n            fn(opcode.pushData!, state.stack)\n    ),\n    ...makeStack(STACK<Expr>()),\n    ...makeState(SYSTEM),\n    PC,\n    INVALID,\n};\n\n/**\n * Swaps `insts` keying by `opcode` and fills the gaps using `INVALID` inst.\n *\n * @param insts\n * @returns\n */\nfunction fill<F>(insts: { [mnemonic in keyof typeof OPCODES]: F }) {\n    return Object.fromEntries(\n        [...Array(256).keys()].map(k => [\n            k,\n            MNEMONICS[k] === undefined ? INVALID : insts[MNEMONICS[k]],\n        ])\n    );\n}\n\nexport class EVM implements IEvents, IStore, ISelectorBranches {\n    /**\n     *\n     */\n    private readonly insts: {\n        [opcode in string]: (opcode: Opcode, state: TState<Inst, Expr>) => void;\n    };\n\n    /**\n     *\n     */\n    readonly chunks = new Map<number, { pcend: number; states: State[] }>();\n\n    /**\n     *\n     */\n    readonly errors: Invalid[] = [];\n\n    readonly events: IEvents['events'] = {};\n    readonly variables: IStore['variables'] = {};\n    readonly mappings: IStore['mappings'] = {};\n    readonly functionBranches: ISelectorBranches['functionBranches'] = new Map<\n        string,\n        { pc: number; state: State }\n    >();\n\n    /**\n     * The `Opcode[]` decoded from `bytecode`.\n     */\n    readonly opcodes: ReturnType<typeof decode>['opcodes'];\n\n    /**\n     * Jump destination (`JUMPDEST`) offsets found in `bytecode`.\n     * This is used to speed up offset search.\n     */\n    readonly jumpdests: ReturnType<typeof decode>['jumpdests'];\n\n    private constructor(\n        { opcodes, jumpdests }: ReturnType<typeof decode>,\n\n        /**\n         * The `metadataHash` part from the `bytecode`.\n         * That is, if present, the `bytecode` without its `code`.\n         */\n        readonly metadata?: Metadata\n    ) {\n        this.opcodes = opcodes;\n        this.jumpdests = jumpdests;\n\n        this.insts = fill({\n            ...TABLE,\n            ...FLOW({ opcodes, jumpdests }, this),\n            ...makeState(STORAGE(this)),\n            ...makeState(LOGS(this)),\n        });\n    }\n\n    /**\n     *\n     * @param bytecode\n     * @returns\n     */\n    static from(bytecode: string): EVM {\n        /**\n         * The `code` part from the `bytecode`.\n         * That is, the `bytecode` without its metadata hash, if any.\n         */\n        const [code, metadata] = stripMetadataHash(bytecode);\n        return new EVM(decode(Buffer.from(code.replace('0x', ''), 'hex')), metadata);\n    }\n\n    /**\n     *\n     */\n    start() {\n        this.run(0, new TState());\n        for (const [, branch] of this.functionBranches) {\n            this.run(branch.pc, branch.state);\n        }\n    }\n\n    run(pc0: number, state: State) {\n        const branches: Branch[] = [new Branch(pc0, state)];\n        while (branches.length > 0) {\n            // The non-null assertion operator `!` is required because the guard does not track array's emptiness.\n            // See https://github.com/microsoft/TypeScript/issues/30406.\n            const branch = branches.shift()!;\n\n            const chunk = this.chunks.get(branch.pc);\n            if (chunk !== undefined && chunk.states.length > 10) {\n                continue;\n            }\n\n            this.exec(branch.pc, branch.state);\n            const last = branch.state.last! as IInst;\n            if (last.next) {\n                for (const b of last.next()) {\n                    // const s = gc(b, this.chunks);\n                    // if (s === undefined) {\n                    branches.unshift(b);\n                    // } else {\n                    //     b.state = s;\n                    // }\n                }\n                // branches.unshift(...last.next());\n            }\n        }\n    }\n\n    exec(pc0: number, state: State) {\n        if (state.halted) throw new Error(`State at ${pc0} must be non-halted to be \\`exec\\``);\n\n        let pc = pc0;\n        const oplen = this.opcodes.length;\n        for (; !state.halted && pc < oplen; pc++) {\n            const opcode = this.opcodes[pc];\n            try {\n                this.insts[opcode.opcode](opcode, state);\n                if (\n                    !state.halted &&\n                    pc < oplen + 1 &&\n                    this.opcodes[pc + 1].opcode === OPCODES.JUMPDEST\n                ) {\n                    const fallBranch = makeBranch(opcode.pc + 1, state);\n                    state.halt(new JumpDest(fallBranch));\n                }\n            } catch (err) {\n                const message = (err as Error).message;\n                const inv = new Invalid(\n                    `\\`${message}\\` at [${opcode.offset}] ${opcode.mnemonic} =| ${state.stack.values\n                        .slice(0, -1)\n                        .join(' | ')}`\n                );\n                state.halt(inv);\n                this.errors.push(inv);\n            }\n        }\n\n        if (!state.halted) throw new Error(`State must be halted after exec at ${pc0}:${pc}`);\n\n        let chunk = this.chunks.get(pc0);\n        if (chunk === undefined) {\n            chunk = {\n                pcend: pc,\n                states: [state],\n            };\n            this.chunks.set(pc0, chunk);\n        } else {\n            chunk.states.push(state);\n        }\n    }\n}\n\nexport function gc(b: Branch, chunks: EVM['chunks']) {\n    const chunk = chunks.get(b.pc);\n    if (chunk !== undefined) {\n        for (const s of chunk.states) {\n            if (cmp(b.state, s)) {\n                return s;\n            }\n        }\n    }\n    return undefined;\n}\n\nfunction cmp({ stack: lhs }: TState<Inst, Expr>, { stack: rhs }: TState<Inst, Expr>) {\n    if (lhs.values.length !== rhs.values.length) {\n        return false;\n    }\n    for (let i = 0; i < lhs.values.length; i++) {\n        if (!cmpval(lhs.values[i], rhs.values[i])) {\n            return false;\n        }\n    }\n    return true;\n\n    function cmpval(lhs: Expr, rhs: Expr) {\n        return !(lhs.isVal() && lhs.isPush) || !(rhs.isVal() && rhs.isPush) || lhs.val === rhs.val;\n    }\n}\n","import type { State } from '../state';\nimport { type Expr, type Inst, Val, type IInst } from './expr';\nimport { MLoad } from './memory';\n\n/**\n *\n */\nexport interface IEvents {\n    /**\n     * Events found through `LOG` instructions.\n     *\n     * The `topic` is represented as a hex string.\n     */\n    readonly events: {\n        [topic: string]: {\n            /**\n             * The signature of the event when the `topic` selector is found.\n             *\n             * For instance, if the topic is\n             * `4d6ce1e535dbade1c23defba91e23b8f791ce5edc0cc320257a2b364e4e38426`,\n             * then `sig` will be `Deposit(uint256)`.\n             */\n            sig?: string;\n            indexedCount: number;\n        };\n    };\n}\n\n/**\n *\n * @param events\n * @returns\n */\nexport function stringifyEvents(events: IEvents['events']) {\n    let text = '';\n\n    for (const [topic, event] of Object.entries(events)) {\n        text += 'event ';\n        if (event.sig === undefined) {\n            text += topic;\n        } else {\n            const eventName = event.sig.split('(')[0];\n            const params = event.sig.replace(eventName, '').substring(1).slice(0, -1);\n            if (params) {\n                text += eventName + '(';\n                text += params\n                    .split(',')\n                    .map((param, i) =>\n                        i < event.indexedCount ? `${param} indexed _arg${i}` : `${param} _arg${i}`\n                    )\n                    .join(', ');\n                text += ')';\n            } else {\n                text += event.sig;\n            }\n        }\n        text += ';\\n';\n    }\n\n    return text;\n}\n\nexport class Log implements IInst {\n    readonly name = 'Log';\n\n    constructor(\n        readonly event: IEvents['events'][string] | undefined,\n        readonly topics: Expr[],\n        readonly args: Expr[],\n        readonly mem?: { offset: Expr; size: Expr }\n    ) {}\n\n    get eventName(): string | undefined {\n        if (this.event !== undefined && this.event.sig !== undefined) {\n            return this.event.sig.split('(')[0];\n        }\n        return undefined;\n    }\n\n    eval() {\n        return new Log(\n            this.event,\n            this.topics.map(e => e.eval()),\n            this.args.map(e => e.eval()),\n            this.mem ? { offset: this.mem.offset.eval(), size: this.mem.size.eval() } : undefined\n        );\n    }\n\n    toString() {\n        return this.eventName\n            ? `emit ${this.eventName}(${[...this.topics.slice(1), ...this.args].join(', ')});`\n            : 'log(' +\n                  (this.mem\n                      ? [...this.topics, `memory[${this.mem.offset}:${this.mem.size} ]`].join(\n                            ', '\n                        ) + 'ii'\n                      : [...this.topics, ...this.args].join(', ')) +\n                  ');';\n    }\n}\n\nexport const LOGS = (events: IEvents) => {\n    return {\n        LOG0: log(0, events),\n        LOG1: log(1, events),\n        LOG2: log(2, events),\n        LOG3: log(3, events),\n        LOG4: log(4, events),\n    };\n};\n\nfunction log(topicsCount: number, { events }: IEvents) {\n    return ({ stack, memory, stmts }: State<Inst, Expr>): void => {\n        let offset = stack.pop();\n        let size = stack.pop();\n\n        const topics = [];\n        for (let i = 0; i < topicsCount; i++) {\n            topics.push(stack.pop());\n        }\n\n        let event: IEvents['events'][string] | undefined = undefined;\n        if (topics.length > 0 && topics[0].isVal()) {\n            const eventTopic = topics[0].val.toString(16).padStart(64, '0');\n            event = events[eventTopic];\n            if (event === undefined) {\n                event = { indexedCount: topics.length - 1 };\n                events[eventTopic] = event;\n            }\n        }\n\n        offset = offset.eval();\n        size = size.eval();\n        stmts.push(\n            offset.isVal() && size.isVal()\n                ? (() => {\n                      const args = [];\n                      for (let i = Number(offset.val); i < Number(offset.val + size.val); i += 32) {\n                          args.push(i in memory ? memory[i] : new MLoad(new Val(BigInt(i))));\n                      }\n                      return new Log(event, topics, args);\n                  })()\n                : new Log(event, topics, [], { offset, size })\n        );\n    };\n}\n","import type { Stack } from '../state';\nimport { type Expr, Tag, Bin, Val } from './expr';\nimport { bin } from './math';\n\nfunction Cmp<N extends string>(tag: N, op: string) {\n    abstract class Cmp extends Tag(tag, 9) {\n        constructor(readonly left: Expr, readonly right: Expr, readonly equal: boolean = false) {\n            super();\n        }\n\n        str() {\n            return `${this.left._str(Cmp.prec)} ${\n                this.equal ? `${op}=` : `${op}`\n            } ${this.right._str(Cmp.prec)}`;\n        }\n    }\n\n    return Cmp;\n}\n\nfunction Unary<N extends string>(tag: N, op: string, prec: number) {\n    abstract class Unary extends Tag(tag, prec) {\n        constructor(readonly value: Expr) {\n            super();\n        }\n\n        str() {\n            return `${op}${this.value._str(prec)}`;\n        }\n    }\n\n    return Unary;\n}\n\nfunction Shift<N extends string>(tag: N, op: string) {\n    abstract class Shift extends Tag(tag, Byte.prec) {\n        constructor(readonly value: Expr, readonly shift: Expr) {\n            super();\n        }\n\n        str() {\n            return `${this.value._str(Shift.prec)} ${op} ${this.shift._str(Shift.prec)}`;\n        }\n    }\n\n    return Shift;\n}\n\nexport class Lt extends Cmp('Lt', '<') {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal() ? new Val(lhs.val < rhs.val ? 1n : 0n) : new Lt(lhs, rhs);\n    }\n}\n\nexport class Gt extends Cmp('Gt', '>') {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal() ? new Val(lhs.val > rhs.val ? 1n : 0n) : new Gt(lhs, rhs);\n    }\n}\n\nexport class Eq extends Bin('Eq', '==', 8) {\n    eval(): Expr {\n        return new Eq(this.left.eval(), this.right.eval());\n    }\n}\n\nexport class IsZero extends Tag('IsZero', Eq.prec) {\n    constructor(readonly value: Expr) {\n        super();\n    }\n    eval(): Expr {\n        const val = this.value.eval();\n        return val.isVal()\n            ? val.val === 0n\n                ? new Val(1n)\n                : new Val(0n)\n            : val.tag === 'Lt'\n            ? new Gt(val.left, val.right, !val.equal)\n            : val.tag === 'Gt'\n            ? new Lt(val.left, val.right, !val.equal)\n            : val.tag === 'IsZero'\n            ? val.value\n            : new IsZero(val);\n    }\n    str(): string {\n        return this.value.tag === 'Eq'\n            ? this.value.left._str(IsZero.prec) + ' != ' + this.value.right._str(IsZero.prec)\n            : this.value._str(IsZero.prec) + ' == 0';\n    }\n}\n\nexport class And extends Bin('And', '&&', 4) {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal()\n            ? new Val(lhs.val & rhs.val)\n            : lhs.isVal() && /^[f]+$/.test(lhs.val.toString(16))\n            ? rhs\n            : rhs.isVal() && /^[f]+$/.test(rhs.val.toString(16))\n            ? lhs\n            : lhs.isVal() && rhs.tag === 'And' && rhs.left.isVal() && lhs.val === rhs.left.val\n            ? rhs.right\n            : new And(lhs, rhs);\n    }\n}\n\nexport class Or extends Bin('Or', '||', 3) {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal() ? new Val(lhs.val | rhs.val) : new Or(lhs, rhs);\n    }\n}\n\nexport class Xor extends Bin('Xor', '^', 6) {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal() ? new Val(lhs.val ^ rhs.val) : new Xor(lhs, rhs);\n    }\n}\n\nexport class Not extends Unary('Not', '~', 14) {\n    eval(): Expr {\n        const val = this.value.eval();\n        return val.isVal() ? new Val(~val.val) : new Not(val);\n    }\n}\n\nexport class Byte extends Tag('Byte', 10) {\n    constructor(readonly pos: Expr, readonly data: Expr) {\n        super();\n    }\n    eval(): Expr {\n        const pos = this.pos.eval();\n        const data = this.data.eval();\n        return data.isVal() && pos.isVal()\n            ? new Val((data.val >> pos.val) & 1n)\n            : new Byte(pos, data);\n    }\n    str(): string {\n        return `(${this.data._str(Byte.prec)} >> ${this.pos._str(Byte.prec)}) & 1`;\n    }\n}\n\nexport class Shl extends Shift('Shl', '<<') {\n    eval(): Expr {\n        const val = this.value.eval();\n        const shift = this.shift.eval();\n        return val.isVal() && shift.isVal() ? new Val(val.val << shift.val) : new Shl(val, shift);\n    }\n}\n\nexport class Shr extends Shift('Shr', '>>>') {\n    eval(): Expr {\n        const val = this.value.eval();\n        const shift = this.shift.eval();\n        return val.isVal() && shift.isVal() ? new Val(val.val >> shift.val) : new Shr(val, shift);\n    }\n}\n\nexport class Sar extends Shift('Sar', '>>') {\n    eval(): Expr {\n        const val = this.value.eval();\n        const shift = this.shift.eval();\n        return val.isVal() && shift.isVal() ? new Val(val.val >> shift.val) : new Sar(val, shift);\n    }\n}\n\nexport class Sig extends Tag('Sig', Eq.prec) {\n    constructor(readonly selector: string) {\n        super();\n    }\n    eval(): Expr {\n        return this;\n    }\n    str(): string {\n        return `msg.sig == ${this.selector}`;\n    }\n}\n\nfunction fromSHRsig(left: Expr, right: Expr, cc: () => Sig | Eq) {\n    if (\n        left.isVal() &&\n        right.tag === 'Shr' &&\n        right.shift.isVal() &&\n        right.shift.val === 0xe0n &&\n        right.value.tag === 'CallDataLoad' &&\n        right.value.location.isZero()\n    ) {\n        return new Sig(left.val.toString(16).padStart(8, '0'));\n    }\n    return cc();\n}\n\nfunction fromDIVEXPsig(left: Expr, right: Expr, cc: () => Sig | Eq) {\n    left = left.eval();\n    right = right.eval();\n\n    if (left.isVal() && right.tag === 'Div' && right.right.isVal()) {\n        const selector = left.val * right.right.val;\n        right = right.left;\n\n        if (\n            selector % (1n << 0xe0n) === 0n &&\n            right.tag === 'CallDataLoad' &&\n            right.location.isZero()\n        ) {\n            return new Sig(\n                selector\n                    .toString(16)\n                    .substring(0, 8 - (64 - selector.toString(16).length))\n                    .padStart(8, '0')\n            );\n        }\n    }\n\n    return cc();\n}\n\nfunction eqHook(left: Expr, right: Expr, cc: () => Eq) {\n    return fromDIVEXPsig(left, right, () =>\n        fromDIVEXPsig(right, left, () => fromSHRsig(left, right, () => fromSHRsig(right, left, cc)))\n    );\n}\n\nexport const LOGIC = {\n    LT: bin(Lt),\n    GT: bin(Gt),\n    SLT: bin(Lt),\n    SGT: bin(Gt),\n\n    EQ: (stack: Stack<Expr>): void => {\n        const left = stack.pop();\n        const right = stack.pop();\n\n        stack.push(\n            left.isVal() && right.isVal()\n                ? left.val === right.val\n                    ? new Val(1n)\n                    : new Val(0n)\n                : eqHook(left, right, () => new Eq(left, right))\n        );\n    },\n\n    ISZERO: (stack: Stack<Expr>): void => {\n        const value = stack.pop();\n        stack.push(new IsZero(value));\n    },\n\n    AND: bin(And),\n    OR: bin(Or),\n    XOR: bin(Xor),\n    NOT: (stack: Stack<Expr>): void => {\n        const value = stack.pop();\n        stack.push(new Not(value));\n    },\n\n    BYTE: (stack: Stack<Expr>): void => {\n        const position = stack.pop();\n        const data = stack.pop();\n        stack.push(new Byte(position, data));\n    },\n\n    SHL: shift(Shl),\n    SHR: shift(Shr),\n    SAR: shift(Sar),\n};\n\nexport function shift(Cons: new (value: Expr, shift: Expr) => Expr): (stack: Stack<Expr>) => void {\n    return function (stack: Stack<Expr>) {\n        const shift = stack.pop();\n        const value = stack.pop();\n        stack.push(new Cons(value, shift));\n    };\n}\n","import type { Stack } from '../state';\nimport { Bin, type Expr, Val } from './expr';\nimport { Sar, Shl } from './logic';\n\nexport class Add extends Bin('Add', '+', 11) {\n    eval(): Expr {\n        const left = this.left.eval();\n        const right = this.right.eval();\n        return left.isVal() && right.isVal()\n            ? new Val(left.val + right.val)\n            : left.isZero()\n            ? right\n            : right.isZero()\n            ? left\n            : new Add(left, right);\n    }\n}\n\nexport class Mul extends Bin('Mul', '*', 12) {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal()\n            ? new Val(lhs.val * rhs.val)\n            : lhs.isZero() || rhs.isZero()\n            ? new Val(0n)\n            : new Mul(lhs, rhs);\n    }\n}\n\nexport class Sub extends Bin('Sub', '-', Add.prec) {\n    eval(): Expr {\n        const left = this.left.eval();\n        const right = this.right.eval();\n        return left.isVal() && right.isVal()\n            ? new Val(left.val - right.val)\n            : right.isZero()\n            ? left\n            : new Sub(left, right);\n    }\n}\n\nexport class Div extends Bin('Div', '/', Mul.prec) {\n    eval(): Expr {\n        const left = this.left.eval();\n        const right = this.right.eval();\n        return left.isVal() && right.isVal()\n            ? right.val === 0n\n                ? new Div(left, right)\n                : new Val(left.val / right.val)\n            : right.isVal() && right.val === 1n\n            ? left\n            : new Div(left, right);\n    }\n}\n\nexport class Mod extends Bin('Mod', '%', Mul.prec) {\n    eval(): Expr {\n        const lhs = this.left.eval();\n        const rhs = this.right.eval();\n        return lhs.isVal() && rhs.isVal() ? new Val(lhs.val % rhs.val) : new Mod(lhs, rhs);\n    }\n}\n\nexport class Exp extends Bin('Exp', '**', 14) {\n    eval(): Expr {\n        const left = this.left.eval();\n        const right = this.right.eval();\n        return left.isVal() && right.isVal() && right.val >= 0\n            ? new Val(left.val ** right.val)\n            : new Exp(left, right);\n    }\n}\n\nexport const MATH = {\n    ADD: bin(Add),\n    MUL: bin(Mul),\n    SUB: bin(Sub),\n    DIV: bin(Div),\n    SDIV: bin(Div),\n    MOD: bin(Mod),\n    SMOD: bin(Mod),\n\n    ADDMOD: (stack: Stack<Expr>): void => {\n        const left = stack.pop();\n        const right = stack.pop();\n        const mod = stack.pop();\n        stack.push(\n            left.isVal() && right.isVal() && mod.isVal()\n                ? new Val((left.val + right.val) % mod.val)\n                : left.isVal() && right.isVal()\n                ? new Mod(new Val(left.val + right.val), mod)\n                : new Mod(new Add(left, right), mod)\n        );\n    },\n\n    MULMOD: (stack: Stack<Expr>): void => {\n        const left = stack.pop();\n        const right = stack.pop();\n        const mod = stack.pop();\n        stack.push(\n            left.isVal() && right.isVal() && mod.isVal()\n                ? new Val((left.val * right.val) % mod.val)\n                : left.isVal() && right.isVal()\n                ? new Mod(new Val(left.val * right.val), mod)\n                : new Mod(new Mul(left, right), mod)\n        );\n    },\n\n    EXP: bin(Exp),\n\n    SIGNEXTEND: (stack: Stack<Expr>): void => {\n        const left = stack.pop();\n        const right = stack.pop();\n        stack.push(\n            left.isVal() && right.isVal()\n                ? new Val((right.val << (32n - left.val)) >> (32n - left.val))\n                : left.isVal()\n                ? new Sar(new Shl(right, new Val(32n - left.val)), new Val(32n - left.val))\n                : new Sar(new Shl(right, new Sub(new Val(32n), left)), new Sub(new Val(32n), left))\n        );\n    },\n};\n\nexport function bin(Cons: new (lhs: Expr, rhs: Expr) => Expr): (stack: Stack<Expr>) => void {\n    return function (stack: Stack<Expr>) {\n        const lhs = stack.pop();\n        const rhs = stack.pop();\n        stack.push(new Cons(lhs, rhs));\n    };\n}\n","import type { State } from '../state';\nimport { type Inst, Tag, type Expr, type IInst } from './expr';\n\nexport class MLoad extends Tag('MLoad') {\n    /**\n     * Loads word from memory.\n     *\n     * @param loc\n     */\n    constructor(readonly loc: Expr) {\n        super();\n    }\n\n    eval(): this {\n        return this;\n    }\n\n    str(): string {\n        return `memory[${this.loc}]`;\n    }\n}\n\nexport class MStore implements IInst {\n    readonly name = 'MStore';\n\n    constructor(readonly location: Expr, readonly data: Expr) {}\n\n    eval() {\n        return this;\n    }\n\n    toString(): string {\n        return `memory[${this.location}] = ${this.data};`;\n    }\n}\n\nexport const MEMORY = {\n    MLOAD: ({ stack, memory }: State<Inst, Expr>): void => {\n        let loc = stack.pop();\n        loc = loc.eval();\n        stack.push(\n            loc.isVal() && Number(loc.val) in memory ? memory[Number(loc.val)] : new MLoad(loc)\n        );\n    },\n    MSTORE: mstore,\n    MSTORE8: mstore,\n};\n\nfunction mstore({ stack, memory, stmts }: State<Inst, Expr>): void {\n    let loc = stack.pop();\n    const data = stack.pop();\n\n    loc = loc.eval();\n    if (loc.isVal()) {\n        memory[Number(loc.val)] = data;\n    } else {\n        stmts.push(new MStore(loc, data));\n    }\n}\n","import { type Expr, Val } from './expr';\nimport { toHex } from '../opcode';\nimport { type Stack } from '../state';\n\nexport const PUSHES = {\n    PUSH1: push,\n    PUSH2: push,\n    PUSH3: push,\n    PUSH4: push,\n    PUSH5: push,\n    PUSH6: push,\n    PUSH7: push,\n    PUSH8: push,\n    PUSH9: push,\n    PUSH10: push,\n    PUSH11: push,\n    PUSH12: push,\n    PUSH13: push,\n    PUSH14: push,\n    PUSH15: push,\n    PUSH16: push,\n    PUSH17: push,\n    PUSH18: push,\n    PUSH19: push,\n    PUSH20: push,\n    PUSH21: push,\n    PUSH22: push,\n    PUSH23: push,\n    PUSH24: push,\n    PUSH25: push,\n    PUSH26: push,\n    PUSH27: push,\n    PUSH28: push,\n    PUSH29: push,\n    PUSH30: push,\n    PUSH31: push,\n    PUSH32: push,\n};\n\nfunction push(pushData: Uint8Array, stack: Stack<Expr>): void {\n    stack.push(new Val(BigInt('0x' + toHex(pushData)), true));\n}\n\nexport function STACK<E>() {\n    return {\n        POP: (stack: Stack<Expr>): void => void stack.pop(),\n        DUP1: dup(0),\n        DUP2: dup(1),\n        DUP3: dup(2),\n        DUP4: dup(3),\n        DUP5: dup(4),\n        DUP6: dup(5),\n        DUP7: dup(6),\n        DUP8: dup(7),\n        DUP9: dup(8),\n        DUP10: dup(9),\n        DUP11: dup(10),\n        DUP12: dup(11),\n        DUP13: dup(12),\n        DUP14: dup(13),\n        DUP15: dup(14),\n        DUP16: dup(15),\n        SWAP1: swap(1),\n        SWAP2: swap(2),\n        SWAP3: swap(3),\n        SWAP4: swap(4),\n        SWAP5: swap(5),\n        SWAP6: swap(6),\n        SWAP7: swap(7),\n        SWAP8: swap(8),\n        SWAP9: swap(9),\n        SWAP10: swap(10),\n        SWAP11: swap(11),\n        SWAP12: swap(12),\n        SWAP13: swap(13),\n        SWAP14: swap(14),\n        SWAP15: swap(15),\n        SWAP16: swap(16),\n    };\n\n    function dup(position: number) {\n        return (stack: Stack<E>): void => stack.dup(position);\n    }\n\n    function swap(position: number) {\n        return (stack: Stack<E>): void => stack.swap(position);\n    }\n}\n","import type { State } from '../state';\nimport { type Expr, type IInst, type Inst, Tag } from './expr';\nimport type { Sha3 } from './system';\n\nexport interface IStore {\n    /**\n     * vars definition\n     */\n    readonly variables: { [location: string]: Variable };\n\n    /**\n     * mappings definition\n     */\n    readonly mappings: {\n        [location: string]: {\n            name: string | undefined;\n            structs: bigint[];\n            keys: Expr[][];\n            values: Expr[];\n        };\n    };\n}\n\n/**\n *\n */\nexport class Variable {\n    constructor(public label: string | undefined, readonly types: Expr[]) {}\n}\n\n/**\n *\n * @param variables\n * @returns\n */\nexport function stringifyVariables(variables: IStore['variables']) {\n    let output = '';\n    Object.entries(variables).forEach(([hash, variable], index) => {\n        const types: string[] = variable.types\n            .map(expr => expr.eval())\n            .map(expr => (!expr.isVal() ? '???expr.type' ?? '' : 'bigint'))\n            .filter(t => t.trim() !== '');\n        if (types.length === 0) {\n            types.push('unknown');\n        }\n        const name = variable.label ? ` public ${variable.label}` : ` var${index + 1}`;\n        output += [...new Set(types)].join('|') + name + '; // #' + hash;\n        output += '\\n';\n    });\n\n    if (Object.keys(variables).length > 0) {\n        output += '\\n';\n    }\n\n    return output;\n}\n\n/**\n *\n * @param mappings\n * @returns\n */\nexport function stringifyStructs(mappings: IStore['mappings']) {\n    let text = '';\n\n    Object.keys(mappings)\n        .filter(key => mappings[key].structs.length > 0)\n        .forEach(key => {\n            const mapping = mappings[key];\n            text += `struct ${mapping.name}Struct {\\n`;\n            mapping.structs.forEach(struct => {\n                text += `    ${struct.toString()};\\n`;\n            });\n            text += '}\\n\\n';\n        });\n\n    return text;\n}\n\n/**\n *\n * @param mappings\n * @returns\n */\nexport function stringifyMappings(mappings: IStore['mappings']) {\n    let output = '';\n\n    Object.keys(mappings).forEach((key: string, index: number) => {\n        const mapping = mappings[key];\n        if (mapping.name) {\n            output += stringifyMapping(mapping) + ' public ' + mapping.name + ';';\n        } else {\n            output += stringifyMapping(mapping) + ` mapping${index + 1};`;\n        }\n        output += '\\n';\n    });\n\n    if (Object.keys(mappings).length > 0) {\n        output += '\\n';\n    }\n\n    return output;\n\n    function stringifyMapping(mapping: IStore['mappings'][keyof IStore['mappings']]) {\n        const mappingKey: string[] = [];\n        const mappingValue: string[] = [];\n        let deepMapping = false;\n        mapping.keys\n            .filter(mappingChild => mappingChild.length > 0)\n            .forEach(mappingChild => {\n                const mappingChild0 = mappingChild[0];\n                if (\n                    mappingChild.length > 0 &&\n                    mappingChild0.type &&\n                    !mappingKey.includes(mappingChild0.type)\n                ) {\n                    mappingKey.push(mappingChild0.type);\n                }\n                if (mappingChild.length > 1 && !deepMapping) {\n                    deepMapping = true;\n                    mappingValue.push(\n                        stringifyMapping({\n                            name: mapping.name,\n                            structs: mapping.structs,\n                            keys: mapping.keys.map(items => {\n                                items.shift();\n                                return items;\n                            }),\n                            values: mapping.values,\n                        })\n                    );\n                } else if (mappingChild.length === 1 && !deepMapping) {\n                    mapping.values.forEach(mappingChild2 => {\n                        if (mappingChild2.type && !mappingValue.includes(mappingChild2.type)) {\n                            mappingValue.push(mappingChild2.type);\n                        }\n                    });\n                }\n            });\n        if (mappingKey.length === 0) {\n            mappingKey.push('unknown');\n        }\n        if (mapping.structs.length > 0 && mappingValue.length === 0) {\n            mappingValue.push(`${mapping.name}Struct`);\n        } else if (mappingValue.length === 0) {\n            mappingValue.push('unknown');\n        }\n        return 'mapping (' + mappingKey.join('|') + ' => ' + mappingValue.join('|') + ')';\n    }\n}\n\nexport class MappingStore implements IInst {\n    readonly name = 'MappingStore';\n\n    constructor(\n        readonly mappings: IStore['mappings'],\n        readonly location: number,\n        readonly items: Expr[],\n        readonly data: Expr,\n        readonly structlocation?: bigint\n    ) {\n        const loc = location;\n        if (!(loc in mappings)) {\n            mappings[loc] = { name: undefined, structs: [], keys: [], values: [] };\n        }\n        mappings[loc].keys.push(items);\n        if (structlocation === undefined) {\n            mappings[loc].values.push(data);\n        }\n    }\n\n    eval() {\n        return this;\n    }\n\n    toString() {\n        let mappingName = `mapping${this.location + 1}`;\n        if (this.location in this.mappings && this.mappings[this.location].name) {\n            mappingName = this.mappings[this.location].name!;\n        }\n\n        if (\n            this.data.tag === 'Add' &&\n            this.data.right.tag === 'MappingLoad' &&\n            this.data.right.location === this.location\n        ) {\n            return (\n                mappingName +\n                this.items.map(item => '[' + item.str() + ']').join('') +\n                ' += ' +\n                this.data.left.str() +\n                ';'\n            );\n        } else if (\n            this.data.tag === 'Add' &&\n            this.data.left.tag === 'MappingLoad' &&\n            this.data.left.location === this.location\n        ) {\n            return (\n                mappingName +\n                this.items.map(item => '[' + item.str() + ']').join('') +\n                ' += ' +\n                this.data.right.str() +\n                ';'\n            );\n        } else if (\n            this.data.tag === 'Sub' &&\n            this.data.left.tag === 'MappingLoad' &&\n            this.data.left.location === this.location\n        ) {\n            return (\n                mappingName +\n                this.items.map(item => '[' + item.str() + ']').join('') +\n                ' -= ' +\n                this.data.right.str() +\n                ';'\n            );\n        } else {\n            return (\n                mappingName +\n                this.items.map(item => `[${item.str()}]`).join('') +\n                ' = ' +\n                this.data.str() +\n                ';'\n            );\n        }\n    }\n}\n\nexport class SStore {\n    readonly name = 'SStore';\n\n    constructor(\n        readonly location: Expr,\n        readonly data: Expr,\n        readonly variables: IStore['variables']\n    ) {\n        // if (isVal(this.location)) {\n        //     const loc = this.location.toString();\n        //     if (loc in this.variables) {\n        //         this.variables[loc].types.push(this.data.type);\n        //     } else {\n        //         this.variables[loc] = new Variable(undefined, [this.data.type]);\n        //     }\n        // }\n    }\n\n    eval() {\n        return new SStore(this.location.eval(), this.data.eval(), this.variables);\n    }\n\n    toString() {\n        let variableName = 'storage[' + this.location.str() + ']';\n        if (this.location.isVal() && this.location.val.toString() in this.variables) {\n            const loc = this.location.val.toString();\n            const label = this.variables[loc].label;\n            if (label) {\n                variableName = label;\n            } else {\n                variableName = `var${Object.keys(this.variables).indexOf(loc) + 1}`;\n            }\n        }\n        if (\n            this.data.tag === 'Add' &&\n            this.data.left.tag === 'SLoad' &&\n            this.data.left.location.str() === this.location.str()\n        ) {\n            return variableName + ' += ' + this.data.right.str() + ';';\n        } else if (\n            this.data.tag === 'Sub' &&\n            this.data.left.tag === 'SLoad' &&\n            this.data.left.location.str() === this.location.str()\n        ) {\n            return variableName + ' -= ' + this.data.right.str() + ';';\n        } else {\n            return variableName + ' = ' + this.data.str() + ';';\n        }\n    }\n}\n\nexport class MappingLoad extends Tag('MappingLoad') {\n    constructor(\n        readonly mappings: IStore['mappings'],\n        readonly location: number,\n        readonly items: Expr[],\n        readonly structlocation?: bigint\n    ) {\n        super();\n        if (!(location in mappings)) {\n            mappings[location] = {\n                name: undefined,\n                structs: [],\n                keys: [],\n                values: [],\n            };\n        }\n        mappings[location].keys.push(items);\n    }\n\n    eval() {\n        return this;\n    }\n\n    str(): string {\n        let mappingName = `mapping${this.location + 1}`;\n        const maybeName = this.mappings[this.location].name;\n        if (this.location in this.mappings && maybeName) {\n            mappingName = maybeName;\n        }\n        if (this.structlocation) {\n            return (\n                mappingName +\n                this.items.map(item => `[${item.str()}]`).join('') +\n                '[' +\n                this.structlocation.toString() +\n                ']'\n            );\n        } else {\n            return mappingName + this.items.map(item => '[' + item.str() + ']').join('');\n        }\n    }\n}\n\nexport class SLoad extends Tag('SLoad') {\n    constructor(readonly location: Expr, readonly variables: IStore['variables']) {\n        super();\n    }\n\n    eval(): Expr {\n        return new SLoad(this.location.eval(), this.variables);\n    }\n\n    str(): string {\n        if (this.location.isVal() && this.location.val.toString() in this.variables) {\n            const loc = this.location.val.toString();\n            const label = this.variables[loc].label;\n            if (label) {\n                return label;\n            } else {\n                return `var${Object.keys(this.variables).indexOf(loc) + 1}`;\n            }\n        } else {\n            return 'storage[' + this.location.str() + ']';\n        }\n    }\n}\n\nfunction parseSha3(sha: Sha3): [number | undefined, Expr[]] {\n    const shas = [sha];\n    const mappings = [];\n    let base = undefined;\n    while (shas.length > 0) {\n        const sha = shas.shift()!;\n        for (const arg of sha.args) {\n            if (arg.tag === 'Sha3' && arg.args) {\n                shas.unshift(arg);\n            } else if (base === undefined && arg.tag === 'Val') {\n                base = Number(arg.val);\n            } else {\n                mappings.unshift(arg);\n            }\n        }\n    }\n    return [base, mappings];\n}\n\nexport const STORAGE = ({ variables, mappings }: IStore) => {\n    return {\n        SLOAD: ({ stack }: State<Inst, Expr>): void => {\n            const loc = stack.pop();\n\n            if (loc.tag === 'Sha3') {\n                const [base, parts] = parseSha3(loc);\n                if (base !== undefined && parts.length > 0) {\n                    stack.push(new MappingLoad(mappings, base, parts));\n                } else {\n                    stack.push(new SLoad(loc, variables));\n                }\n            } else if (loc.tag === 'Add' && loc.left.tag === 'Sha3' && loc.right.isVal()) {\n                const [base, parts] = parseSha3(loc.left);\n                if (base !== undefined && parts.length > 0) {\n                    stack.push(new MappingLoad(mappings, base, parts, loc.right.val));\n                } else {\n                    stack.push(new SLoad(loc, variables));\n                }\n            } else if (loc.tag === 'Add' && loc.left.isVal() && loc.right.tag === 'Sha3') {\n                const [base, parts] = parseSha3(loc.right);\n                if (base !== undefined && parts.length > 0) {\n                    stack.push(new MappingLoad(mappings, base, parts, loc.left.val));\n                } else {\n                    stack.push(new SLoad(loc, variables));\n                }\n            } else {\n                stack.push(new SLoad(loc, variables));\n            }\n        },\n\n        SSTORE: ({ stack, stmts }: State<Inst, Expr>): void => {\n            const loc = stack.pop();\n            const data = stack.pop();\n\n            if (loc.isVal()) {\n                sstoreVariable();\n            } else if (loc.tag === 'Sha3') {\n                const [base, parts] = parseSha3(loc);\n                if (base !== undefined && parts.length > 0) {\n                    stmts.push(new MappingStore(mappings, base, parts, data));\n                } else {\n                    sstoreVariable();\n                }\n            } else if (loc.tag === 'Add' && loc.left.tag === 'Sha3' && loc.right.isVal()) {\n                const [base, parts] = parseSha3(loc.left);\n                if (base !== undefined && parts.length > 0) {\n                    stmts.push(new MappingStore(mappings, base, parts, data, loc.right.val));\n                } else {\n                    sstoreVariable();\n                }\n            } else if (loc.tag === 'Add' && loc.left.isVal() && loc.right.tag === 'Sha3') {\n                const [base, parts] = parseSha3(loc.right);\n                if (base !== undefined && parts.length > 0) {\n                    stmts.push(new MappingStore(mappings, base, parts, data, loc.left.val));\n                } else {\n                    sstoreVariable();\n                }\n            } else {\n                sstoreVariable();\n            }\n\n            function sstoreVariable() {\n                if (loc.isVal()) {\n                    const key = loc.val.toString();\n                    if (key in variables) {\n                        variables[key].types.push(data);\n                    } else {\n                        variables[key] = new Variable(undefined, [data]);\n                    }\n                }\n                stmts.push(new SStore(loc, data, variables));\n            }\n        },\n    };\n};\n","import type { Ram } from '../state';\nimport { type Expr, Tag, Val } from './expr';\n\nexport const INFO = {\n    ADDRESS: 'this',\n    ORIGIN: 'tx.origin',\n    CALLER: 'msg.sender',\n    CODESIZE: 'this.code.length',\n    GASPRICE: 'tx.gasprice',\n    RETURNDATASIZE: 'output.length',\n    COINBASE: 'block.coinbase',\n    TIMESTAMP: 'block.timestamp',\n    NUMBER: 'block.number',\n    DIFFICULTY: 'block.difficulty',\n    GASLIMIT: 'block.gaslimit',\n    CHAINID: 'chainid',\n    SELFBALANCE: 'self.balance',\n    MSIZE: 'memory.length',\n    GAS: 'gasleft()',\n} as const;\n\nexport type Info = (typeof INFO)[keyof typeof INFO];\n\nexport class Symbol0 extends Tag('Symbol0') {\n    constructor(readonly symbol: Info, readonly type2?: string | undefined) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return this.symbol;\n    }\n}\n\nexport class Symbol1 extends Tag('Symbol1') {\n    constructor(readonly fn: (value: string) => string, readonly value: Expr) {\n        super();\n    }\n\n    eval(): Expr {\n        return new Symbol1(this.fn, this.value.eval());\n    }\n\n    str(): string {\n        return this.fn(this.value._str(Val.prec));\n    }\n}\n\nexport class DataCopy extends Tag('DataCopy') {\n    constructor(\n        readonly fn: (offset: string, size: string) => string,\n        readonly offset: Expr,\n        readonly size: Expr\n    ) {\n        super();\n    }\n\n    eval(): this {\n        return this;\n    }\n\n    str(): string {\n        return this.fn(this.offset.str(), this.size.str());\n    }\n}\n\nexport const SYM = {\n    ...(Object.fromEntries(Object.entries(INFO).map(([name, value]) => [name, symbol0(value)])) as {\n        [name in keyof typeof INFO]: ReturnType<typeof symbol0>;\n    }),\n    // ADDRESS: symbol0('this', 'address'),\n    BALANCE: symbol1(address => `${address}.balance`),\n    // ORIGIN: symbol0('tx.origin'),\n    // CALLER: symbol0('msg.sender'),\n    CALLDATACOPY: datacopy((offset, size) => `msg.data[${offset}:(${offset}+${size})];`),\n    // CODESIZE: symbol0('this.code.length'),\n    CODECOPY: datacopy((offset, size) => `this.code[${offset}:(${offset}+${size})]`),\n    // GASPRICE: symbol0('tx.gasprice'),\n    EXTCODESIZE: symbol1(address => `address(${address}).code.length`),\n    EXTCODECOPY: ({ stack }: Ram<Expr>): void => {\n        const address = stack.pop();\n        datacopy((offset, size) => `address(${address.str()}).code[${offset}:(${offset}+${size})]`);\n    },\n    // RETURNDATASIZE: symbol0('output.length'),\n    RETURNDATACOPY: datacopy((offset, size) => `output[${offset}:(${offset}+${size})]`),\n    EXTCODEHASH: symbol1(address => `keccak256(address(${address}).code)`),\n\n    // Block Information\n    BLOCKHASH: symbol1(blockNumber => `blockhash(${blockNumber})`),\n    // COINBASE: symbol0('block.coinbase'),\n    // TIMESTAMP: symbol0('block.timestamp'),\n    // NUMBER: symbol0('block.number'),\n    // DIFFICULTY: symbol0('block.difficulty'),\n    // GASLIMIT: symbol0('block.gaslimit'),\n    // CHAINID: symbol0('chainid'),\n    // SELFBALANCE: symbol0('self.balance'),\n    // MSIZE: symbol0('memory.length'),\n    // GAS: symbol0('gasleft()'),\n};\n\nfunction symbol0(value: Info, type?: string) {\n    return ({ stack }: Ram<Expr>) => {\n        stack.push(new Symbol0(value, type));\n    };\n}\n\nfunction symbol1(fn: (value: string) => string) {\n    return ({ stack }: Ram<Expr>) => {\n        const value = stack.pop();\n        stack.push(new Symbol1(fn, value));\n    };\n}\n\nexport function datacopy(fn: (offset: string, size: string) => string) {\n    return ({ stack, memory }: Ram<Expr>): void => {\n        const dest = stack.pop();\n        const offset = stack.pop();\n        const size = stack.pop();\n        if (!dest.isVal()) {\n            // throw new Error('expected number in returndatacopy');\n        } else {\n            memory[Number(dest.val)] = new DataCopy(fn, offset, size);\n        }\n    };\n}\n","import type { Opcode } from '../opcode';\nimport type { State } from '../state';\nimport { type IInst, Tag, Val, type Expr, type Inst } from './expr';\nimport { MLoad } from './memory';\n\nexport class Sha3 extends Tag('Sha3') {\n    constructor(readonly args: Expr[], readonly memoryStart?: Expr, readonly memoryLength?: Expr) {\n        super();\n    }\n\n    eval(): Expr {\n        return new Sha3(\n            this.args.map(e => e.eval()),\n            this.memoryStart,\n            this.memoryLength\n        );\n    }\n\n    str(): string {\n        return this.memoryStart && this.memoryLength\n            ? `keccak256(memory[${this.memoryStart}:(${this.memoryStart}+${this.memoryLength})])`\n            : `keccak256(${this.args.join(', ')})`;\n    }\n}\n\nexport class Create extends Tag('Create') {\n    override readonly type = 'address';\n\n    /**\n     * Creates a new account with associated code.\n     *\n     * @param value Value in _wei_ to send to the new account.\n     * @param offset Byte offset in the memory in bytes, the initialisation code for the new account.\n     * @param size Byte size to copy (size of the initialisation code).\n     */\n    constructor(readonly value: Expr, readonly offset: Expr, readonly size: Expr) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return `new Contract(memory[${this.offset}..${this.offset}+${this.size}]).value(${this.value}).address`;\n    }\n}\n\nexport class Call extends Tag('Call') {\n    throwOnFail = false;\n\n    constructor(\n        readonly gas: Expr,\n        readonly address: Expr,\n        readonly value: Expr,\n        readonly memoryStart: Expr,\n        readonly memoryLength: Expr,\n        readonly outputStart: Expr,\n        readonly outputLength: Expr\n    ) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        if (this.memoryLength.isZero() && this.outputLength.isZero()) {\n            if (\n                this.gas.tag === 'Mul' &&\n                this.gas.left.isZero() &&\n                this.gas.right.isVal() &&\n                this.gas.right.val === 2300n\n            ) {\n                if (this.throwOnFail) {\n                    return `address(${this.address}).transfer(${this.value})`;\n                } else {\n                    return `address(${this.address}).send(${this.value})`;\n                }\n            } else {\n                return `address(${this.address}).call.gas(${this.gas}).value(${this.value})`;\n            }\n        } else {\n            return `call(${this.gas},${this.address},${this.value},${this.memoryStart},${this.memoryLength},${this.outputStart},${this.outputLength})`;\n        }\n    }\n}\n\nexport class ReturnData extends Tag('ReturnData') {\n    readonly name = 'ReturnData';\n    override readonly type?: string;\n    readonly wrapped = false;\n\n    constructor(readonly retOffset: any, readonly retSize: any) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n    str(): string {\n        return `output:ReturnData:${this.retOffset}:${this.retSize}`;\n    }\n}\n\nexport class CallCode extends Tag('CallCode') {\n    readonly name = 'CallCode';\n\n    constructor(\n        readonly gas: Expr,\n        readonly address: Expr,\n        readonly value: Expr,\n        readonly memoryStart: Expr,\n        readonly memoryLength: Expr,\n        readonly outputStart: Expr,\n        readonly outputLength: Expr\n    ) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return `callcode(${this.gas},${this.address},${this.value},${this.memoryStart},${this.memoryLength},${this.outputStart},${this.outputLength})`;\n    }\n}\n\nexport class Create2 extends Tag('Create2') {\n    constructor(readonly offset: Expr, readonly size: Expr, readonly value: Expr) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return `new Contract(memory[${this.offset}:(${this.offset}+${this.size})]).value(${this.value}).address`;\n    }\n}\n\nexport class StaticCall extends Tag('StaticCall') {\n    constructor(\n        readonly gas: Expr,\n        readonly address: Expr,\n        readonly memoryStart: Expr,\n        readonly memoryLength: Expr,\n        readonly outputStart: Expr,\n        readonly outputLength: Expr\n    ) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return `staticcall(${this.gas},${this.address},${this.memoryStart},${this.memoryLength},${this.outputStart},${this.outputLength})`;\n    }\n}\n\nexport class DelegateCall extends Tag('DelegateCall') {\n    constructor(\n        readonly gas: Expr,\n        readonly address: Expr,\n        readonly memoryStart: Expr,\n        readonly memoryLength: Expr,\n        readonly outputStart: Expr,\n        readonly outputLength: Expr\n    ) {\n        super();\n    }\n\n    eval(): Expr {\n        return this;\n    }\n\n    str(): string {\n        return `delegatecall(${this.gas},${this.address},${this.memoryStart},${this.memoryLength},${this.outputStart},${this.outputLength})`;\n    }\n}\n\nexport class Stop implements IInst {\n    readonly name = 'Stop';\n\n    eval() {\n        return this;\n    }\n\n    toString() {\n        return 'return;';\n    }\n}\n\nexport class Return implements IInst {\n    readonly name = 'Return';\n\n    /**\n     * Exits the current context successfully.\n     *\n     * @param args\n     * @param offset Byte offset in the memory in bytes, to copy what will be the return data of this context.\n     * @param size Byte size to copy (size of the return data).\n     */\n    constructor(readonly args: Expr[], readonly offset?: Expr, readonly size?: Expr) {}\n\n    eval() {\n        return this;\n    }\n\n    toString(): string {\n        if (this.offset && this.size) {\n            return `return memory[${this.offset}:(${this.offset}+${this.size})];`;\n        } else if (this.args.length === 0) {\n            return 'return;';\n        } else if (isStringReturn(this.args) && this.args[0].val === 32n) {\n            return `return '${hex2a(this.args[2].val.toString(16))}';`;\n        } else {\n            return this.args.length === 1\n                ? `return ${this.args[0]};`\n                : `return (${this.args.join(', ')});`;\n        }\n    }\n}\n\nfunction isStringReturn(args: Expr[]): args is [Val, Val, Val] {\n    return args.length === 3 && args.every(arg => arg.isVal());\n}\n\nfunction hex2a(hexstr: string) {\n    let str = '';\n    for (let i = 0; i < hexstr.length && hexstr.slice(i, i + 2) !== '00'; i += 2) {\n        str += String.fromCharCode(parseInt(hexstr.substring(i, i + 2), 16));\n    }\n    return str;\n}\n\nexport class Revert implements IInst {\n    readonly name = 'Revert';\n\n    constructor(readonly args: Expr[], readonly offset?: Expr, readonly size?: Expr) {}\n\n    eval() {\n        return this;\n    }\n\n    toString() {\n        return this.offset && this.size\n            ? `revert(memory[${this.offset}:(${this.offset}+${this.size})]);`\n            : `revert(${this.args.join(', ')});`;\n    }\n}\n\nexport class Invalid implements IInst {\n    readonly name = 'Invalid';\n\n    constructor(readonly reason: string) {}\n\n    eval() {\n        return this;\n    }\n\n    toString() {\n        return `revert('${this.reason}');`;\n    }\n}\n\nexport class SelfDestruct implements IInst {\n    readonly name = 'SelfDestruct';\n\n    constructor(readonly address: Expr) {}\n\n    eval() {\n        return this;\n    }\n\n    toString() {\n        return `selfdestruct(${this.address});`;\n    }\n}\n\nexport function memArgs<T>(\n    { stack, memory }: State<Inst, Expr>,\n    Klass: new (args: Expr[], offset?: Expr, size?: Expr) => T\n): T {\n    const MAXSIZE = 1024;\n\n    let offset = stack.pop();\n    let size = stack.pop();\n\n    offset = offset.eval();\n    size = size.eval();\n\n    if (offset.isVal() && size.isVal() && size.val <= MAXSIZE * 32) {\n        const args = [];\n        for (let i = Number(offset.val); i < Number(offset.val + size.val); i += 32) {\n            args.push(i in memory ? memory[i].eval() : new MLoad(new Val(BigInt(i))));\n        }\n\n        return new Klass(args);\n    } else {\n        if (size.isVal() && size.val > MAXSIZE * 32) {\n            throw new Error(`memargs size${Klass.toString()}${size.val}`);\n        }\n\n        return new Klass([], offset, size);\n    }\n}\n\nexport const SYSTEM = {\n    SHA3: (state: State<Inst, Expr>): void => state.stack.push(memArgs(state, Sha3)),\n    STOP: (state: State<Inst, Expr>): void => state.halt(new Stop()),\n\n    CREATE: ({ stack }: State<Inst, Expr>): void => {\n        const value = stack.pop();\n        const offset = stack.pop();\n        const size = stack.pop();\n        stack.push(new Create(value, offset, size));\n    },\n\n    CALL: ({ stack, memory }: State<Inst, Expr>): void => {\n        const gas = stack.pop();\n        const address = stack.pop();\n        const value = stack.pop();\n        const memoryStart = stack.pop();\n        const memoryLength = stack.pop();\n        const outputStart = stack.pop();\n        const outputLength = stack.pop();\n        stack.push(\n            new Call(gas, address, value, memoryStart, memoryLength, outputStart, outputLength)\n        );\n\n        // if (typeof outputStart !== 'number') {\n        //     console.log('WARN:CALL outstart should be number');\n        // }\n\n        memory[outputStart as any as number] = new ReturnData(outputStart, outputLength);\n    },\n    CALLCODE: ({ stack }: State<Inst, Expr>): void => {\n        const gas = stack.pop();\n        const address = stack.pop();\n        const value = stack.pop();\n        const memoryStart = stack.pop();\n        const memoryLength = stack.pop();\n        const outputStart = stack.pop();\n        const outputLength = stack.pop();\n\n        stack.push(\n            new CallCode(gas, address, value, memoryStart, memoryLength, outputStart, outputLength)\n        );\n    },\n\n    RETURN: (state: State<Inst, Expr>): void => state.halt(memArgs(state, Return)),\n\n    DELEGATECALL: ({ stack }: State<Inst, Expr>): void => {\n        const gas = stack.pop();\n        const address = stack.pop();\n        const memoryStart = stack.pop();\n        const memoryLength = stack.pop();\n        const outputStart = stack.pop();\n        const outputLength = stack.pop();\n        stack.push(\n            new DelegateCall(gas, address, memoryStart, memoryLength, outputStart, outputLength)\n        );\n    },\n\n    CREATE2: ({ stack }: State<Inst, Expr>): void => {\n        const value = stack.pop();\n        const memoryStart = stack.pop();\n        const memoryLength = stack.pop();\n        stack.push(new Create2(memoryStart, memoryLength, value));\n    },\n\n    STATICCALL: ({ stack }: State<Inst, Expr>): void => {\n        const gas = stack.pop();\n        const address = stack.pop();\n        const memoryStart = stack.pop();\n        const memoryLength = stack.pop();\n        const outputStart = stack.pop();\n        const outputLength = stack.pop();\n        stack.push(\n            new StaticCall(gas, address, memoryStart, memoryLength, outputStart, outputLength)\n        );\n    },\n\n    REVERT: (state: State<Inst, Expr>): void => state.halt(memArgs(state, Revert)),\n\n    SELFDESTRUCT: (state: State<Inst, Expr>): void => {\n        const address = state.stack.pop();\n        state.halt(new SelfDestruct(address));\n    },\n};\n\nexport const PC = (opcode: Opcode, { stack }: State<Inst, Expr>) =>\n    stack.push(new Val(BigInt(opcode.offset)));\n\nexport const INVALID = (opcode: Opcode, state: State<Inst, Expr>): void => {\n    state.halt(new Invalid(`Invalid instruction (0x${opcode.opcode.toString(16)})`));\n};\n","const BZZR0 = '627a7a7230';\nconst BZZR1 = '627a7a7231';\nconst IPFS = '69706673';\n\nconst SOLC = '736f6c63';\n\nconst protocols: [RegExp, 'bzzr' | 'ipfs'][] = [\n    /**\n     * https://docs.soliditylang.org/en/v0.5.8/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n     */\n    [new RegExp(`a165${BZZR0}5820([a-f0-9]{64})0029$`), 'bzzr'],\n\n    /**\n     * https://docs.soliditylang.org/en/v0.5.9/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n     * https://blog.soliditylang.org/2019/05/28/solidity-0.5.9-release-announcement/\n     */\n    [new RegExp(`a265${BZZR1}5820([a-f0-9]{64})64${SOLC}43([a-f0-9]{6})0032$`), 'bzzr'],\n\n    /**\n     * v0.6.2 ends with `0x00 0x33` but v0.6.1 ends with `0x00 0x32`\n     * https://blog.soliditylang.org/2019/12/17/solidity-0.6.0-release-announcement/\n     * https://docs.soliditylang.org/en/v0.6.2/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n     */\n    [new RegExp(`a264${IPFS}5822([a-f0-9]{68})64${SOLC}43([a-f0-9]{6})0033$`), 'ipfs'],\n];\n\n/**\n * Represents the metadata hash protocols embedded in bytecode by `solc`.\n */\nexport class Metadata {\n    constructor(readonly protocol: 'bzzr' | 'ipfs', readonly hash: string, readonly solc: string) {}\n\n    get url(): string {\n        return `${this.protocol}://${this.hash}`;\n    }\n}\n\n/**\n * Splits the `bytecode` into executable code and embedded metadata hash as\n * placed by the Solidity compiler, if present in the `bytecode`.\n *\n * @param bytecode the contract `bytecode` to test for metadata hash from, hex encoded.\n * @returns An tuple where the first component is the executable code and\n * second one is the metadata hash when the metadata is present.\n * Otherwise, the original `bytecode` and `undefined` respectively.\n */\nexport function stripMetadataHash(bytecode: string): [string, Metadata | undefined] {\n    for (const [re, protocol] of protocols) {\n        const match = bytecode.match(re);\n        if (match && match[1]) {\n            return [\n                bytecode.substring(0, match.index),\n                new Metadata(protocol, match[1], match[2] ? convertVersion(match[2]) : '<0.5.9'),\n            ];\n        }\n    }\n\n    return [bytecode, undefined];\n\n    /**\n     *\n     * @param solcVersion\n     * @returns\n     */\n    function convertVersion(solcVersion: string) {\n        const slice = (pos: number) => parseInt(solcVersion.slice(pos, pos + 2), 16).toString();\n        return `${slice(0)}.${slice(2)}.${slice(4)}`;\n    }\n}\n","/**\n * Set of `PUSHn` opcodes.\n */\nconst PUSHES = {\n    PUSH1: 0x60,\n    PUSH2: 0x61,\n    PUSH3: 0x62,\n    PUSH4: 0x63,\n    PUSH5: 0x64,\n    PUSH6: 0x65,\n    PUSH7: 0x66,\n    PUSH8: 0x67,\n    PUSH9: 0x68,\n    PUSH10: 0x69,\n    PUSH11: 0x6a,\n    PUSH12: 0x6b,\n    PUSH13: 0x6c,\n    PUSH14: 0x6d,\n    PUSH15: 0x6e,\n    PUSH16: 0x6f,\n    PUSH17: 0x70,\n    PUSH18: 0x71,\n    PUSH19: 0x72,\n    PUSH20: 0x73,\n    PUSH21: 0x74,\n    PUSH22: 0x75,\n    PUSH23: 0x76,\n    PUSH24: 0x77,\n    PUSH25: 0x78,\n    PUSH26: 0x79,\n    PUSH27: 0x7a,\n    PUSH28: 0x7b,\n    PUSH29: 0x7c,\n    PUSH30: 0x7d,\n    PUSH31: 0x7e,\n    PUSH32: 0x7f,\n};\n\n/**\n * Set of opcodes defined by the EVM.\n *\n * They are constructed from two kinds of opcodes.\n * `Unary` opcodes which takes no-arguments and,\n * `PUSHn` opcodes which takes an `n` byte argument from the bytecode.\n *\n * From these two different categories is easier to distinguish between the two.\n */\nexport const OPCODES = {\n    STOP: 0x00,\n    ADD: 0x01,\n    MUL: 0x02,\n    SUB: 0x03,\n    DIV: 0x04,\n    SDIV: 0x05,\n    MOD: 0x06,\n    SMOD: 0x07,\n    ADDMOD: 0x08,\n    MULMOD: 0x09,\n    EXP: 0x0a,\n    SIGNEXTEND: 0x0b,\n    LT: 0x10,\n    GT: 0x11,\n    SLT: 0x12,\n    SGT: 0x13,\n    EQ: 0x14,\n    ISZERO: 0x15,\n    AND: 0x16,\n    OR: 0x17,\n    XOR: 0x18,\n    NOT: 0x19,\n    BYTE: 0x1a,\n    SHL: 0x1b,\n    SHR: 0x1c,\n    SAR: 0x1d,\n    SHA3: 0x20,\n    ADDRESS: 0x30,\n    BALANCE: 0x31,\n    ORIGIN: 0x32,\n    CALLER: 0x33,\n    CALLVALUE: 0x34,\n    CALLDATALOAD: 0x35,\n    CALLDATASIZE: 0x36,\n    CALLDATACOPY: 0x37,\n    CODESIZE: 0x38,\n    CODECOPY: 0x39,\n    GASPRICE: 0x3a,\n    EXTCODESIZE: 0x3b,\n    EXTCODECOPY: 0x3c,\n    RETURNDATASIZE: 0x3d,\n    RETURNDATACOPY: 0x3e,\n    EXTCODEHASH: 0x3f,\n    BLOCKHASH: 0x40,\n    COINBASE: 0x41,\n    TIMESTAMP: 0x42,\n    NUMBER: 0x43,\n    DIFFICULTY: 0x44,\n    GASLIMIT: 0x45,\n    CHAINID: 0x46, // https://www.evm.codes/#46\n    SELFBALANCE: 0x47, // https://www.evm.codes/#47\n    POP: 0x50,\n    MLOAD: 0x51,\n    MSTORE: 0x52,\n    MSTORE8: 0x53,\n    SLOAD: 0x54,\n    SSTORE: 0x55,\n    JUMP: 0x56,\n    JUMPI: 0x57,\n    PC: 0x58,\n    MSIZE: 0x59,\n    GAS: 0x5a,\n    JUMPDEST: 0x5b,\n    ...PUSHES,\n    DUP1: 0x80,\n    DUP2: 0x81,\n    DUP3: 0x82,\n    DUP4: 0x83,\n    DUP5: 0x84,\n    DUP6: 0x85,\n    DUP7: 0x86,\n    DUP8: 0x87,\n    DUP9: 0x88,\n    DUP10: 0x89,\n    DUP11: 0x8a,\n    DUP12: 0x8b,\n    DUP13: 0x8c,\n    DUP14: 0x8d,\n    DUP15: 0x8e,\n    DUP16: 0x8f,\n    SWAP1: 0x90,\n    SWAP2: 0x91,\n    SWAP3: 0x92,\n    SWAP4: 0x93,\n    SWAP5: 0x94,\n    SWAP6: 0x95,\n    SWAP7: 0x96,\n    SWAP8: 0x97,\n    SWAP9: 0x98,\n    SWAP10: 0x99,\n    SWAP11: 0x9a,\n    SWAP12: 0x9b,\n    SWAP13: 0x9c,\n    SWAP14: 0x9d,\n    SWAP15: 0x9e,\n    SWAP16: 0x9f,\n    LOG0: 0xa0,\n    LOG1: 0xa1,\n    LOG2: 0xa2,\n    LOG3: 0xa3,\n    LOG4: 0xa4,\n    CREATE: 0xf0,\n    CALL: 0xf1,\n    CALLCODE: 0xf2,\n    RETURN: 0xf3,\n    DELEGATECALL: 0xf4,\n    CREATE2: 0xf5,\n    STATICCALL: 0xfa,\n    REVERT: 0xfd,\n    INVALID: 0xfe,\n    SELFDESTRUCT: 0xff,\n} as const;\n\n/**\n * A map from numeric opcodes to string mnemonics.\n */\nexport const MNEMONICS = Object.fromEntries(\n    Object.entries(OPCODES).map(([key, value]) => [value, key as keyof typeof OPCODES])\n);\n\n/**\n * Represents all unary opcodes defined by the EVM.\n * Essentially, all but `PUSHn` opcodes are unary opcodes.\n */\nexport interface Unary {\n    /**\n     * Represents a valid opcode.\n     *\n     * In https://www.evm.codes/ you can find an overview of each EVM opcode.\n     *\n     * If the `opcode` given is not a valid opcode,\n     * you can provide `INVALID` as `mnemonic`.\n     */\n    mnemonic: Exclude<keyof typeof OPCODES, keyof typeof PUSHES>;\n\n    /**\n     * A `Unary` opcode does not include any `pushData`.\n     */\n    pushData: null;\n}\n\n/**\n * Represents a `PUSHn` mnemonic augmented with its `pushData`.\n */\nexport interface Push {\n    /**\n     * A `PUSHn` opcode only permits a `PUSHn` opcode.\n     */\n    mnemonic: keyof typeof PUSHES;\n\n    /**\n     * If this `Opcode` is a `PUSHn` instruction,\n     * then `pushData` contains the data attached to this instruction.\n     * Otherwise, `null`.\n     */\n    pushData: Uint8Array;\n}\n\n/**\n *\n */\nexport type Opcode = {\n    /**\n     * This is the offset in the bytecode where this `Opcode` was found.\n     * Both jump instructions, _i.e._, `JUMP` and `JUMPI`,\n     * expects a stack operand referencing this `offset` in the bytecode.\n     */\n    readonly offset: number;\n\n    /**\n     * The Program Counter of this `Opcode`.\n     * The index in the `Opcode[]` where this `Opcode` is inserted.\n     */\n    readonly pc: number;\n\n    /**\n     * Any byte number, _i.e._, between 0 and 255 representing the opcode byte.\n     * The `opcode` may not be a valid opcode.\n     */\n    readonly opcode: number;\n} & (Unary | Push);\n\n/**\n * Represents the `Opcode`s found in `code`.\n *\n * @param code the buffer containing the bytecode to decode\n * @returns\n */\nexport function decode(code: Uint8Array): {\n    /**\n     * Represents the `Opcode`s found in `code`.\n     */\n    opcodes: Opcode[];\n    /**\n     * Map between `JUMPDEST` instructions offset, _i.e._,\n     * as they appear in the `code` buffer and its index in the `opcodes` array.\n     *\n     * It allows to quickly find the `JUMPDEST` instruction.\n     */\n    jumpdests: { [jd: number]: number };\n} {\n    const opcodes = [];\n    const jumpdests: { [jd: number]: number } = {};\n\n    for (let i = 0; i < code.length; i++) {\n        const opcode = code[i];\n        const mnemonic = MNEMONICS[opcode] ?? 'INVALID';\n        if (mnemonic === 'JUMPDEST') {\n            jumpdests[i] = opcodes.length;\n        }\n        opcodes.push({\n            offset: i,\n            pc: opcodes.length,\n            opcode,\n            ...(isPush(mnemonic)\n                ? {\n                      mnemonic,\n                      pushData: (() => {\n                          const pushSize = opcode - OPCODES.PUSH1 + 0x01;\n                          const data = code.subarray(i + 1, i + pushSize + 1);\n                          i += pushSize;\n                          return data;\n                      })(),\n                  }\n                : {\n                      mnemonic,\n                      pushData: null,\n                  }),\n        });\n    }\n\n    return { opcodes, jumpdests };\n\n    /**\n     * Asserts whether `mnemonic` is a `PUSHn` opcode.\n     *\n     * @param mnemonic the `mnemonic` to check.\n     * @returns `true` when `mnemonic` is a `PUSHn` opcode.\n     * `false` otherwise.\n     */\n    function isPush(mnemonic: keyof typeof OPCODES): mnemonic is keyof typeof PUSHES {\n        return mnemonic in PUSHES;\n    }\n}\n\nexport function formatOpcode(op: Opcode): string {\n    const offset = op.offset.toString().padStart(4, ' ').toUpperCase();\n    const pc = op.pc.toString().padStart(4, ' ').toUpperCase();\n    const pushData = op.pushData\n        ? ` 0x${toHex(op.pushData)} (${parseInt(toHex(op.pushData), 16)})`\n        : '';\n\n    return `${pc}:${offset}    ${op.mnemonic}${pushData}`;\n}\n\n/**\n *\n * @param buffer\n * @returns\n */\nexport function toHex(buffer: Uint8Array): string {\n    return buffer.reduce((str, elem) => str + elem.toString(16).padStart(2, '0'), '');\n}\n","/**\n *\n */\nexport class Stack<in out T> {\n    readonly values: T[] = [];\n\n    /**\n     *\n     * @param elem\n     */\n    push(elem: T): void | never {\n        if (this.values.length >= 1024) {\n            throw new Stack.Error('Stack too deep');\n        }\n\n        this.values.unshift(elem);\n    }\n\n    pop(): T | never {\n        if (this.values.length === 0) {\n            throw new Stack.Error('POP with empty stack');\n        }\n\n        // The non-null assertion operator `!` is needed here because the\n        // guard `length === 0` does not track array's emptiness.\n        // See https://github.com/microsoft/TypeScript/issues/30406.\n        return this.values.shift()!;\n    }\n\n    dup(position: number): void | never {\n        if (position < 0 || position > 15) {\n            throw new Stack.Error('Unsupported position for duplication operation');\n        } else if (!(position in this.values)) {\n            throw new Stack.Error('Invalid duplication operation, position was not found');\n        }\n\n        this.push(this.values[position]);\n    }\n\n    swap(secondPosition: number): void | never {\n        if (secondPosition < 1 || secondPosition > 16) {\n            throw new Stack.Error('Unsupported position for swap operation');\n        } else if (!(secondPosition in this.values)) {\n            throw new Stack.Error('Invalid swap operation, position was not found');\n        }\n\n        const firstValue = this.values[0];\n        const secondValue = this.values[secondPosition];\n        this.values[0] = secondValue;\n        this.values[secondPosition] = firstValue;\n    }\n\n    clone(): Stack<T> {\n        const stack = new Stack<T>();\n        stack.values.push(...this.values);\n        return stack;\n    }\n\n    static Error = class extends Error {\n        constructor(message: string) {\n            super(message);\n        }\n        override name = 'Stack.Error';\n    };\n}\n\n/**\n * Represents the state of an EVM run with statements `S` and expressions `E`.\n */\nexport class State<S, E> {\n    /**\n     * Indicates whether this `State` has been halted.\n     */\n    private _halted = false;\n\n    /**\n     * The statements executed that lead to this `State`.\n     */\n    readonly stmts: S[] = [];\n\n    /**\n     *\n     * @param stack\n     * @param memory\n     */\n    constructor(readonly stack = new Stack<E>(), readonly memory: { [location: number]: E } = {}) {}\n\n    /**\n     * Indicates whether this `State` has been halted.\n     *\n     * When `true`, no more execution should be allowed against this `State`.\n     */\n    get halted(): boolean {\n        return this._halted;\n    }\n\n    /**\n     * The last statement in this `State`.\n     */\n    get last(): S | undefined {\n        return this.stmts.at(-1);\n    }\n\n    /**\n     * Halts this `State`.\n     * It adds `last` to `stmts` and sets `halted` to `true`.\n     *\n     * @param last The `S` that halts this `State`.\n     */\n    halt(last: S): void {\n        this.stmts.push(last);\n        this._halted = true;\n    }\n\n    /**\n     * Creates a detached clone from this `State`.\n     * The cloned state only shallow copies both `stack` and `memory`,\n     * while `stmts` will be empty and `halted` false.\n     *\n     * Note however the shallow copy means the structure of both `stack` and `memory` are cloned,\n     * not their contents.\n     * This means that any expression `E` in either the `stack` or `memory`\n     * will be shared across instances if they are references.\n     *\n     * @returns a new `State` detached from this one.\n     */\n    clone(): State<S, E> {\n        return new State(this.stack.clone(), { ...this.memory });\n    }\n}\n\n/**\n * Represents the volatile memory of `State`, _i.e._, its `stack` and `memory`.\n */\nexport type Ram<E> = Pick<State<never, E>, 'stack' | 'memory'>;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import type { Expr, Inst } from './evm/expr';\nimport { Not } from './evm/logic';\nimport type { Revert } from './evm/system';\nimport { State } from './state';\nimport { EVM } from './evm';\nimport { stringifyEvents } from './evm/log';\nimport { stringifyMappings, stringifyStructs, stringifyVariables } from './evm/storage';\nimport { OPCODES } from './opcode';\n\n/**\n *\n */\nexport class Contract {\n    /**\n     *\n     */\n    readonly evm: EVM;\n\n    /**\n     *\n     */\n    readonly main: Stmt[];\n\n    /**\n     *\n     */\n    readonly functions: { [selector: string]: PublicFunction } = {};\n\n    constructor(bytecode: string) {\n        this.evm = EVM.from(bytecode);\n        const main = new State<Inst, Expr>();\n        this.evm.run(0, main);\n        this.main = build(main);\n        for (const [selector, branch] of this.evm.functionBranches) {\n            this.evm.run(branch.pc, branch.state);\n            this.functions[selector] = new PublicFunction(build(branch.state), selector);\n        }\n    }\n\n    get metadata(): EVM['metadata'] {\n        return this.evm.metadata;\n    }\n\n    /**\n     *\n     * @returns\n     */\n    getFunctions(): string[] {\n        return Object.values(this.functions).flatMap(fn =>\n            fn.label === undefined ? [] : [fn.label]\n        );\n    }\n\n    // getEvents(): string[] {\n    //     return [\n    //         ...new Set(\n    //             this.opcodes\n    //                 .filter(\n    //                     (opcode): opcode is Opcode & { mnemonic: 'PUSH32' } =>\n    //                         opcode.opcode === OPCODES.PUSH32\n    //                 )\n    //                 .map(opcode => toHex(opcode.pushData))\n    //                 .filter(hash => hash in this.eventHashes)\n    //                 .map(hash => this.eventHashes[hash])\n    //         ),\n    //     ];\n    // }\n\n    // getABI() {\n    //     return Object.values(this.contract).map(fn => {\n    //         return {\n    //             type: 'function',\n    //             name: fn.label.split('(')[0],\n    //             payable: fn.payable,\n    //             constant: fn.constant,\n    //         };\n    //     });\n    // }\n\n    /**\n     * https://eips.ethereum.org/EIPS/eip-165\n     *\n     * @returns\n     */\n    isERC165(): boolean {\n        /**\n         * `bytes4(keccak256('supportsInterface(bytes4)'))`\n         */\n        const selector = '01ffc9a7';\n        return this.evm.functionBranches.has(selector);\n    }\n\n    /**\n     *\n     * @returns\n     */\n    decompile(): string {\n        let text = '';\n\n        text += stringifyEvents(this.evm.events);\n        text += stringifyStructs(this.evm.mappings);\n        text += stringifyMappings(this.evm.mappings);\n        text += stringifyVariables(this.evm.variables);\n        text += stringify(this.main);\n        for (const [, fn] of Object.entries(this.functions)) {\n            text += stringifyFunction(fn);\n        }\n\n        return text;\n    }\n\n    /**\n     * Migrated from old codebase.\n     * Evaluate if it makes sense to keep it.\n     *\n     * @param opcode\n     * @returns\n     */\n    containsOpcode(opcode: number | string): boolean {\n        const HALTS = [\n            OPCODES.STOP,\n            OPCODES.RETURN,\n            OPCODES.REVERT,\n            OPCODES.INVALID,\n            OPCODES.SELFDESTRUCT,\n        ] as number[];\n        let halted = false;\n        if (typeof opcode === 'string' && opcode in OPCODES) {\n            opcode = OPCODES[opcode as keyof typeof OPCODES];\n        } else if (typeof opcode === 'string') {\n            throw new Error('Invalid opcode provided');\n        }\n        for (let index = 0; index < this.evm.opcodes.length; index++) {\n            const currentOpcode = this.evm.opcodes[index].opcode;\n            if (currentOpcode === opcode && !halted) {\n                return true;\n            } else if (currentOpcode === OPCODES.JUMPDEST) {\n                halted = false;\n            } else if (HALTS.includes(currentOpcode)) {\n                halted = true;\n            }\n        }\n        return false;\n\n        // function fromHex(str: string): Uint8Array {\n        //     const buffer = new Uint8Array(str.length / 2);\n        //     for (let i = 0; i < buffer.length; i++) {\n        //         buffer[i] = parseInt(str.substr(i * 2, 2), 16);\n        //     }\n        //     return buffer;\n        // }\n    }\n}\n\nexport class If {\n    readonly name = 'If';\n    constructor(\n        readonly condition: Expr,\n        readonly trueBlock?: Stmt[],\n        readonly falseBlock?: Stmt[]\n    ) {}\n\n    toString() {\n        return `(${this.condition})`;\n    }\n}\n\nexport class CallSite {\n    readonly name = 'CallSite';\n\n    constructor(readonly selector: string) {}\n\n    toString() {\n        return `$${this.selector}();`;\n    }\n}\n\nexport function isRevertBlock(falseBlock: Stmt[]): falseBlock is [Revert] {\n    return (\n        falseBlock.length === 1 && 'name' in falseBlock[0] && falseBlock[0].name === 'Revert' //&&\n        // falseBlock[0].items !== undefined &&\n        // falseBlock[0].items.length === 0\n        // || falseCloneTree[0].name === 'INVALID'\n    );\n}\n\nexport class Require {\n    readonly name = 'Require';\n\n    constructor(readonly condition: Expr, readonly args: Expr[]) {}\n\n    toString() {\n        return `require(${this.condition}, ${this.args.join(', ')});`;\n    }\n}\n\nexport class PublicFunction {\n    /**\n     *\n     */\n    label: string | undefined = undefined;\n    readonly payable: boolean;\n    readonly visibility: string;\n    readonly constant: boolean;\n    readonly returns: [] = [];\n\n    constructor(readonly stmts: Stmt[], readonly selector: string) // readonly gasUsed: number,\n    // functionHashes: { [s: string]: string }\n    {\n        this.payable = true;\n        this.visibility = 'public';\n        this.constant = false;\n        this.returns = [];\n        // this.label = this.hash in functionHashes ? functionHashes[this.hash] : this.hash + '()';\n        if (\n            this.stmts.length > 0 &&\n            this.stmts[0] instanceof Require &&\n            this.stmts[0].condition.tag === 'IsZero' &&\n            this.stmts[0].condition.value.tag === 'CallValue'\n        ) {\n            this.payable = false;\n            this.stmts.shift();\n        }\n        if (this.stmts.length === 1 && this.stmts[0].name === 'Return') {\n            this.constant = true;\n        }\n        // if (this.selector in functionHashes) {\n        // const functionName = functionHashes[this.selector].split('(')[0];\n        // const argumentTypes = functionHashes[this.selector] .replace(functionName, '') .substr(1) .slice(0, -1) .split(',');\n        // if ( argumentTypes.length > 1 || (argumentTypes.length === 1 && argumentTypes[0] !== '')) {\n        // this.stmts.forEach(stmt =>\n        // updateCallDataLoad(stmt as unknown as Record<string, Expr>, argumentTypes)\n        // );\n        // }\n        // }\n    }\n}\n\n// export class Assign {\n//     readonly name = 'Asign';\n//     constructor(readonly i: number, readonly phi: Phi) {}\n//     eval() {\n//         return this;\n//     }\n//     toString() {\n//         return `local${this.i} = ${this.phi.toString()};`;\n//     }\n// }\n\nexport type Stmt = Inst | If | CallSite | Require;\n\nexport function build(state: State<Inst, Expr>): Stmt[] {\n    const visited = new WeakSet();\n    return buildState(state);\n\n    function buildState(state: State<Inst, Expr>): Stmt[] {\n        if (visited.has(state)) {\n            return [];\n        }\n\n        visited.add(state);\n\n        const last = state.last!;\n        if (last === undefined) return [];\n\n        for (let i = 0; i < state.stmts.length; i++) {\n            state.stmts[i] = state.stmts[i].eval();\n        }\n\n        switch (last.name) {\n            case 'Jumpi': {\n                if (last.evalCond.isVal()) {\n                    if (last.evalCond.val === 0n) {\n                        return [...state.stmts.slice(0, -1), ...buildState(last.fallBranch.state)];\n                    } else {\n                        return [...state.stmts.slice(0, -1), ...buildState(last.destBranch.state)];\n                    }\n                }\n\n                const trueBlock = buildState(last.destBranch.state);\n                const falseBlock = buildState(last.fallBranch.state);\n                return [\n                    ...state.stmts.slice(0, -1),\n                    ...(isRevertBlock(falseBlock)\n                        ? [\n                              new Require(\n                                  last.cond.eval(),\n                                  falseBlock[0].args.map(e => e.eval())\n                              ),\n                              ...trueBlock,\n                          ]\n                        : [new If(new Not(last.cond), falseBlock), ...trueBlock]),\n                ];\n            }\n            case 'SigCase': {\n                const falseBlock = buildState(last.fallBranch.state);\n                return [\n                    ...state.stmts.slice(0, -1),\n                    new If(last.condition, [new CallSite(last.condition.selector)], falseBlock),\n                ];\n            }\n            case 'Jump':\n                return [...state.stmts.slice(0, -1), ...buildState(last.destBranch.state)];\n            case 'JumpDest':\n                return [...state.stmts.slice(0, -1), ...buildState(last.fallBranch.state)];\n            default:\n                return state.stmts;\n        }\n    }\n}\n\n/**\n *\n * @param stmts\n * @param indentation\n * @returns\n */\nexport function stringify(stmts: Stmt[], indentation = 0): string {\n    let text = '';\n    for (const stmt of stmts) {\n        if (stmt instanceof If) {\n            const condition = stmt.toString();\n            text += ' '.repeat(indentation) + 'if ' + condition + ' {\\n';\n            text += stringify(stmt.trueBlock!, indentation + 4);\n            if (stmt.falseBlock) {\n                text += ' '.repeat(indentation) + '} else {\\n';\n                text += stringify(stmt.falseBlock, indentation + 4);\n            }\n            text += ' '.repeat(indentation) + '}\\n';\n            // }\n        } else {\n            text += ' '.repeat(indentation) + stmt.toString() + '\\n';\n        }\n    }\n\n    return text;\n}\n\n/**\n *\n * @param functionName\n * @param fn\n * @param functionHashes\n * @returns\n */\nfunction stringifyFunction(fn: PublicFunction): string {\n    let output = '';\n    output += 'function ';\n    if (fn.label !== undefined) {\n        const fullFunction = fn.label;\n        const fullFunctionName = fullFunction.split('(')[0];\n        const fullFunctionArguments = fullFunction\n            .replace(fullFunctionName, '')\n            .substring(1)\n            .slice(0, -1);\n        if (fullFunctionArguments) {\n            output += fullFunctionName + '(';\n            output += fullFunctionArguments\n                .split(',')\n                .map((a: string, i: number) => `${a} _arg${i}`)\n                .join(', ');\n            output += ')';\n        } else {\n            output += fullFunction;\n        }\n    } else {\n        output += fn.selector + '()';\n    }\n    output += ' ' + fn.visibility;\n    if (fn.constant) {\n        output += ' view';\n    }\n    if (fn.payable) {\n        output += ' payable';\n    }\n    if (fn.returns.length > 0) {\n        output += ` returns (${fn.returns.join(', ')})`;\n    }\n    output += ' {\\n';\n    output += stringify(fn.stmts, 4);\n    output += '}\\n\\n';\n    return output;\n}\n"],"names":["CallValue","Tag","eval","this","str","CallDataLoad","constructor","location","super","isVal","val","_str","prec","CallDataSize","ENV","CALLVALUE","stack","push","CALLDATALOAD","pop","CALLDATASIZE","tag","Val","isZero","isJumpDest","jumpDest","text","toString","op","Bin","left","right","isPush","Branch","pc","state","key","Jump","offset","destBranch","name","next","Jumpi","cond","fallBranch","evalCond","SigCase","condition","makeBranch","clone","opcodes","jumpdests","functionBranches","JUMP","_opcode","getDest","halt","JUMPI","opcode","destpc","last","set","selector","offset2","Error","Number","undefined","dest","find","o","formatOpcode","make","table","adapter","Object","fromEntries","entries","map","mnemonic","fn","makeStack","makeState","TABLE","MATH","LOGIC","SYM","MEMORY","JUMPDEST","_state","PUSHES","pushData","STACK","SYSTEM","PC","INVALID","EVM","metadata","insts","chunks","Map","errors","events","variables","mappings","FLOW","STORAGE","LOGS","Array","keys","k","MNEMONICS","static","bytecode","code","stripMetadataHash","decode","Buffer","from","replace","start","run","branch","pc0","branches","length","shift","chunk","get","states","exec","b","unshift","halted","oplen","OPCODES","JumpDest","err","message","inv","Invalid","values","slice","join","pcend","cmp","lhs","rhs","i","cmpval","s","topic","event","sig","eventName","split","params","substring","param","indexedCount","Log","topics","args","mem","e","size","log","topicsCount","memory","stmts","eventTopic","padStart","MLoad","BigInt","LOG0","LOG1","LOG2","LOG3","LOG4","Cmp","equal","Shift","Byte","value","Lt","Gt","Eq","IsZero","And","test","Or","Xor","Not","Unary","pos","data","Shl","Shr","Sar","Sig","fromSHRsig","cc","fromDIVEXPsig","Cons","LT","bin","GT","SLT","SGT","EQ","eqHook","ISZERO","AND","OR","XOR","NOT","BYTE","position","SHL","SHR","SAR","Add","Mul","Sub","Div","Mod","Exp","ADD","MUL","SUB","DIV","SDIV","MOD","SMOD","ADDMOD","mod","MULMOD","EXP","SIGNEXTEND","loc","MStore","mstore","MLOAD","MSTORE","MSTORE8","toHex","PUSH1","PUSH2","PUSH3","PUSH4","PUSH5","PUSH6","PUSH7","PUSH8","PUSH9","PUSH10","PUSH11","PUSH12","PUSH13","PUSH14","PUSH15","PUSH16","PUSH17","PUSH18","PUSH19","PUSH20","PUSH21","PUSH22","PUSH23","PUSH24","PUSH25","PUSH26","PUSH27","PUSH28","PUSH29","PUSH30","PUSH31","PUSH32","POP","DUP1","dup","DUP2","DUP3","DUP4","DUP5","DUP6","DUP7","DUP8","DUP9","DUP10","DUP11","DUP12","DUP13","DUP14","DUP15","DUP16","SWAP1","swap","SWAP2","SWAP3","SWAP4","SWAP5","SWAP6","SWAP7","SWAP8","SWAP9","SWAP10","SWAP11","SWAP12","SWAP13","SWAP14","SWAP15","SWAP16","Variable","label","types","output","forEach","hash","variable","index","expr","filter","t","trim","Set","structs","mapping","struct","stringifyMapping","mappingKey","mappingValue","deepMapping","mappingChild","mappingChild0","type","includes","items","mappingChild2","MappingStore","structlocation","mappingName","item","SStore","variableName","indexOf","MappingLoad","maybeName","SLoad","parseSha3","sha","shas","base","arg","SLOAD","parts","SSTORE","sstoreVariable","INFO","ADDRESS","ORIGIN","CALLER","CODESIZE","GASPRICE","RETURNDATASIZE","COINBASE","TIMESTAMP","NUMBER","DIFFICULTY","GASLIMIT","CHAINID","SELFBALANCE","MSIZE","GAS","Symbol0","symbol","type2","Symbol1","DataCopy","symbol0","symbol1","datacopy","BALANCE","address","CALLDATACOPY","CODECOPY","EXTCODESIZE","EXTCODECOPY","RETURNDATACOPY","EXTCODEHASH","BLOCKHASH","blockNumber","Sha3","memoryStart","memoryLength","Create","Call","gas","outputStart","outputLength","throwOnFail","ReturnData","retOffset","retSize","wrapped","CallCode","Create2","StaticCall","DelegateCall","Stop","Return","every","hexstr","String","fromCharCode","parseInt","hex2a","Revert","reason","SelfDestruct","memArgs","Klass","MAXSIZE","SHA3","STOP","CREATE","CALL","CALLCODE","RETURN","DELEGATECALL","CREATE2","STATICCALL","REVERT","SELFDESTRUCT","SOLC","protocols","RegExp","Metadata","protocol","solc","url","re","match","convertVersion","solcVersion","buffer","reduce","elem","pushSize","subarray","toUpperCase","Stack","secondPosition","firstValue","secondValue","State","_halted","at","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","functions","evm","main","build","PublicFunction","getFunctions","flatMap","isERC165","has","decompile","stringifyEvents","stringifyStructs","stringifyMappings","stringifyVariables","stringify","stringifyFunction","containsOpcode","HALTS","currentOpcode","If","trueBlock","falseBlock","CallSite","isRevertBlock","Require","returns","payable","visibility","constant","visited","WeakSet","buildState","add","indentation","stmt","repeat","fullFunction","fullFunctionName","fullFunctionArguments","a"],"sourceRoot":""}